<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glumpy简单演示 - 发光粒子</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(45deg, #0a0a0a, #1a1a2e, #16213e);
            font-family: 'Courier New', monospace;
        }
        
        canvas {
            display: block;
        }
        
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff88;
            font-size: 16px;
            text-shadow: 0 0 10px #00ff88;
            pointer-events: none;
            z-index: 100;
        }
        
        .title {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff6b6b;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 20px #ff6b6b;
            pointer-events: none;
            z-index: 100;
            letter-spacing: 4px;
        }
    </style>
</head>
<body>
    <div class="info">
        GLUMPY SIMPLE DEMO<br>
        点击鼠标创建粒子爆炸效果
    </div>
    
    <div class="title">SIMPLE GLUMPY</div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // 场景设置
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        camera.position.z = 30;

        // 后处理辉光效果
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            3.0,  // 强度
            1.0,  // 半径
            0.0   // 阈值
        );
        composer.addPass(bloomPass);

        // 粒子爆炸系统
        class SimpleParticleExplosion {
            constructor() {
                this.explosions = [];
                this.setupMouseEvents();
            }
            
            setupMouseEvents() {
                window.addEventListener('click', (event) => {
                    // 将屏幕坐标转换为世界坐标
                    const mouse = new THREE.Vector2();
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    
                    const worldPos = new THREE.Vector3(mouse.x * 20, mouse.y * 15, 0);
                    this.createExplosion(worldPos);
                });
            }
            
            createExplosion(position) {
                const particleCount = 100;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const velocities = [];
                const colors = new Float32Array(particleCount * 3);
                
                // 生成粒子
                for (let i = 0; i < particleCount; i++) {
                    // 初始位置（爆炸中心）
                    positions[i * 3] = position.x;
                    positions[i * 3 + 1] = position.y;
                    positions[i * 3 + 2] = position.z;
                    
                    // 随机速度方向
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 10
                    );
                    velocities.push(velocity);
                    
                    // 随机颜色（Glumpy风格）
                    const hue = Math.random();
                    const color = new THREE.Color().setHSL(hue, 1.0, 0.6);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                // 创建发光材质
                const material = new THREE.PointsMaterial({
                    size: 0.5,
                    vertexColors: true,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const particles = new THREE.Points(geometry, material);
                scene.add(particles);
                
                // 添加到爆炸列表
                this.explosions.push({
                    particles: particles,
                    velocities: velocities,
                    life: 3.0,
                    maxLife: 3.0
                });
            }
            
            update(deltaTime) {
                // 更新所有爆炸
                this.explosions = this.explosions.filter(explosion => {
                    explosion.life -= deltaTime;
                    
                    if (explosion.life <= 0) {
                        scene.remove(explosion.particles);
                        explosion.particles.geometry.dispose();
                        explosion.particles.material.dispose();
                        return false;
                    }
                    
                    // 更新粒子位置
                    const positions = explosion.particles.geometry.attributes.position.array;
                    const colors = explosion.particles.geometry.attributes.color.array;
                    
                    for (let i = 0; i < explosion.velocities.length; i++) {
                        // 应用重力
                        explosion.velocities[i].y -= 9.8 * deltaTime;
                        
                        // 更新位置
                        positions[i * 3] += explosion.velocities[i].x * deltaTime;
                        positions[i * 3 + 1] += explosion.velocities[i].y * deltaTime;
                        positions[i * 3 + 2] += explosion.velocities[i].z * deltaTime;
                        
                        // 淡出效果
                        const alpha = explosion.life / explosion.maxLife;
                        colors[i * 3] *= alpha;
                        colors[i * 3 + 1] *= alpha;
                        colors[i * 3 + 2] *= alpha;
                    }
                    
                    explosion.particles.geometry.attributes.position.needsUpdate = true;
                    explosion.particles.geometry.attributes.color.needsUpdate = true;
                    
                    return true;
                });
            }
        }

        // 背景星空
        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 1000;
            const positions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 200;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 200;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.3,
                transparent: true,
                opacity: 0.6
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
            
            return stars;
        }

        // 初始化
        const explosionSystem = new SimpleParticleExplosion();
        const starField = createStarField();
        
        // 动画循环
        let lastTime = performance.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) * 0.001;
            lastTime = currentTime;
            
            // 旋转星空背景
            starField.rotation.y += deltaTime * 0.1;
            
            // 更新爆炸系统
            explosionSystem.update(deltaTime);
            
            // 渲染
            composer.render();
        }
        
        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>