<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 密度函数引力场(带调试面板)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            text-shadow: 0 0 5px #fff;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="info">密度函数引力场 - 可用鼠标交互</div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'lil-gui';

        // --- 场景、相机和渲染器设置 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 45, 65);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- 鼠标控制器 ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- 光照设置 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffd580, 2, 250);
        scene.add(pointLight);

        // --- 创建中心恒星 ---
        const sun = new THREE.Mesh(
            new THREE.SphereGeometry(2.5, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xffd580 })
        );
        scene.add(sun);
        
        // --- 创建一个总的星系容器 ---
        const galaxyContainer = new THREE.Group();
        scene.add(galaxyContainer);

        // --- 创建星系星球 ---
        const planetsGroup = new THREE.Group();
        const planetCount = 8000;
        const galaxyRadius = 50.0, numArms = 3, armTightness = 8.0, armWidth = 1.2;
        const waveAmplitude = 1.8, waveFrequency = 0.4;
        const maxEmissiveIntensity = 0.7;
        
        // --- 雾气粒子数据 ---
        const fogVertices = [];
        const fogColors = [];
        const fogColor = new THREE.Color('#dddddd');

        for (let i = 0; i < planetCount; i++) {
            const r = Math.pow(Math.random(), 2) * galaxyRadius;
            const armIndex = Math.floor(Math.random() * numArms);
            let angle = Math.log(r + 1) * armTightness + (armIndex * 2 * Math.PI / numArms);
            angle += (Math.random() - 0.5) * armWidth / (r * 0.1 + 1);

            const x = r * Math.cos(angle);
            const z = r * Math.sin(angle);
            const y = waveAmplitude * Math.sin(waveFrequency * r + angle);

            // 创建星球
            const emissiveIntensity = maxEmissiveIntensity * Math.pow(1.0 - (r / galaxyRadius), 2);
            const planet = new THREE.Mesh(
                new THREE.SphereGeometry(Math.random() * 0.12 + 0.05, 16, 16),
                new THREE.MeshStandardMaterial({
                    color: new THREE.Color(Math.random(), Math.random(), Math.random()),
                    metalness: 0.3, roughness: 0.5,
                    emissive: new THREE.Color(0xffffff), emissiveIntensity
                })
            );
            planet.position.set(x, y, z);
            planet.userData = { radius: r, angle: angle };
            planetsGroup.add(planet);

            // 创建雾气粒子
            fogVertices.push(
                x + (Math.random() - 0.5) * 3, 
                y + (Math.random() - 0.5) * 3, 
                z + (Math.random() - 0.5) * 3
            );
            fogColors.push(fogColor.r, fogColor.g, fogColor.b);
        }
        galaxyContainer.add(planetsGroup);
        
        // --- [MODIFIED] GUI 调试面板默认参数 ---
        const params = {
            bloomThreshold: 0.0,
            bloomStrength: 0.4,
            bloomRadius: 0.2,
            fogOpacity: 0.01,
            fogSize: 3,
        };

        // --- 创建雾气 ---
        const fogGeometry = new THREE.BufferGeometry();
        fogGeometry.setAttribute('position', new THREE.Float32BufferAttribute(fogVertices, 3));
        fogGeometry.setAttribute('color', new THREE.Float32BufferAttribute(fogColors, 3));

        const generateFogTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.5)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        };

        const fogMaterial = new THREE.PointsMaterial({
            size: params.fogSize, // [MODIFIED] 使用参数初始化
            map: generateFogTexture(),
            blending: THREE.AdditiveBlending, depthWrite: false,
            transparent: true, vertexColors: true, opacity: params.fogOpacity // [MODIFIED] 使用参数初始化
        });
        const fogPoints = new THREE.Points(fogGeometry, fogMaterial);
        galaxyContainer.add(fogPoints);

        // --- 创建背景星空 ---
        const starVertices = [];
        for (let i = 0; i < 10000; i++) starVertices.push((Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000);
        const starGeometry = new THREE.BufferGeometry();
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starField = new THREE.Points(starGeometry, new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, transparent: true, opacity: 0.8 }));
        scene.add(starField);

        // --- 后期处理 ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // [MODIFIED] 将默认参数应用到效果上
        bloomPass.threshold = params.bloomThreshold;
        bloomPass.strength = params.bloomStrength;
        bloomPass.radius = params.bloomRadius;

        // --- 创建并设置GUI ---
        const gui = new GUI();
        const bloomFolder = gui.addFolder('辉光效果 (Bloom)');
        bloomFolder.add(params, 'bloomThreshold', 0, 1, 0.01).name('辉光-阈值').onChange(v => bloomPass.threshold = v);
        bloomFolder.add(params, 'bloomStrength', 0, 3, 0.01).name('辉光-强度').onChange(v => bloomPass.strength = v);
        bloomFolder.add(params, 'bloomRadius', 0, 1, 0.01).name('辉光-半径').onChange(v => bloomPass.radius = v);
        
        const fogFolder = gui.addFolder('雾气效果 (Fog)');
        fogFolder.add(params, 'fogOpacity', 0, 1, 0.01).name('雾气-不透明度').onChange(v => fogMaterial.opacity = v);
        fogFolder.add(params, 'fogSize', 1, 20, 1).name('雾气-尺寸').onChange(v => fogMaterial.size = v);


        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            sun.rotation.y += 0.005;
            galaxyContainer.rotation.y -= 0.0005;

            planetsGroup.children.forEach(planet => {
                const { radius, angle } = planet.userData;
                const speed = 0.5 / (radius + 1);
                planet.userData.angle += speed * 0.02;
                planet.position.x = radius * Math.cos(planet.userData.angle);
                planet.position.z = radius * Math.sin(planet.userData.angle);
                planet.position.y = waveAmplitude * Math.sin(waveFrequency * radius + planet.userData.angle);
            });

            controls.update();
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
