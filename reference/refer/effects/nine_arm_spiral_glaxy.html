<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 九悬臂旋涡星系模型</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        .info { position: absolute; top: 10px; width: 100%; text-align: center; color: white; font-family: Arial, sans-serif; font-size: 16px; text-shadow: 0 0 5px #fff; pointer-events: none; }
    </style>
</head>
<body>
    <div class="info">九悬臂旋涡星系 - 可用鼠标交互</div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'lil-gui';

        // --- 场景、相机和渲染器 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 70);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- 控制器和光照 ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        scene.add(new THREE.AmbientLight(0xffffff, 0.1));
        scene.add(new THREE.PointLight(0xffd580, 2, 250));

        // --- 中心恒星和星系容器 ---
        const sun = new THREE.Mesh(new THREE.SphereGeometry(2.5, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffd580 }));
        scene.add(sun);
        const galaxyContainer = new THREE.Group();
        scene.add(galaxyContainer);

        const planetsGroup = new THREE.Group();
        galaxyContainer.add(planetsGroup);
        
        // --- 参数定义 ---
        const params = {
            bloomThreshold: 0.0,
            bloomStrength: 0.4,
            bloomRadius: 0.2,
            fogOpacity: 0.01,
            fogSize: 3,
            // 银河系结构参数
            galaxyRadius: 60.0, // 星系总半径
            armTightness: 4.0, // 旋臂紧密程度
            armWidth: 1.5, // 旋臂宽度
            numArms: 9 // [MODIFIED] 悬臂数量
        };
        const planetCount = 12000; // 增加粒子数以填充更多悬臂

        // --- 生成粒子 ---
        const fogVertices = [], fogColors = [];
        const fogColor = new THREE.Color('#dddddd');

        function createGalaxy() {
            // 清空旧的粒子
            while(planetsGroup.children.length > 0) planetsGroup.remove(planetsGroup.children[0]);
            fogVertices.length = 0;
            fogColors.length = 0;

            for (let i = 0; i < planetCount; i++) {
                // 1. 随机生成一个半径
                const r = Math.pow(Math.random(), 2) * params.galaxyRadius;
                
                // --- [MODIFIED] 9悬臂逻辑 ---
                const armIndex = i % params.numArms; // 分配到9条臂中的一条
                const angleOffset = (2 * Math.PI / params.numArms) * armIndex; // 计算每条臂的起始角度偏移
                let angle = Math.log(r + 1) * params.armTightness + angleOffset;
                
                // 2. 增加旋臂内的随机偏移，形成宽度
                const randomOffset = (Math.random() - 0.5) * params.armWidth / (r * 0.1 + 1);
                angle += randomOffset;

                // 3. 计算最终位置 (包含Z轴上的正弦波扰动)
                const waveAmplitude = 1.8, waveFrequency = 0.4;
                const x = r * Math.cos(angle);
                const z = r * Math.sin(angle);
                const y = waveAmplitude * Math.sin(waveFrequency * r + angle);

                // 创建星球
                const emissiveIntensity = 0.7 * Math.pow(1.0 - (r / params.galaxyRadius), 2);
                const planet = new THREE.Mesh(
                    new THREE.SphereGeometry(Math.random() * 0.12 + 0.05, 16, 16),
                    new THREE.MeshStandardMaterial({
                        color: new THREE.Color(Math.random(), Math.random(), Math.random()),
                        metalness: 0.3, roughness: 0.5,
                        emissive: new THREE.Color(0xffffff), emissiveIntensity
                    })
                );
                planet.position.set(x, y, z);
                planet.userData = { radius: r, angle: angle };
                planetsGroup.add(planet);

                // 创建雾气粒子
                fogVertices.push(x + (Math.random() - 0.5) * 3, y + (Math.random() - 0.5) * 3, z + (Math.random() - 0.5) * 3);
                fogColors.push(fogColor.r, fogColor.g, fogColor.b);
            }

            // 更新雾气几何体
            fogGeometry.setAttribute('position', new THREE.Float32BufferAttribute(fogVertices, 3));
            fogGeometry.setAttribute('color', new THREE.Float32BufferAttribute(fogColors, 3));
            fogGeometry.attributes.position.needsUpdate = true;
        }

        // --- 创建雾气 (初始化) ---
        const fogGeometry = new THREE.BufferGeometry();
        const generateFogTexture = () => { /* ... (函数内容不变) ... */
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.5)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient; context.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        };
        const fogMaterial = new THREE.PointsMaterial({
            size: params.fogSize, map: generateFogTexture(),
            blending: THREE.AdditiveBlending, depthWrite: false,
            transparent: true, vertexColors: true, opacity: params.fogOpacity
        });
        const fogPoints = new THREE.Points(fogGeometry, fogMaterial);
        galaxyContainer.add(fogPoints);

        // --- 创建背景星空 ---
        const starVertices = [];
        for (let i = 0; i < 15000; i++) starVertices.push((Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000);
        const starGeometry = new THREE.BufferGeometry();
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starField = new THREE.Points(starGeometry, new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, transparent: true, opacity: 0.8 }));
        scene.add(starField);
        
        // --- 后期处理 ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = params.bloomThreshold;
        bloomPass.strength = params.bloomStrength;
        bloomPass.radius = params.bloomRadius;
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- GUI 调试面板 ---
        const gui = new GUI();
        const structureFolder = gui.addFolder('星系结构 (Structure)');
        structureFolder.add(params, 'galaxyRadius', 30, 100, 1).name('星系总半径').onFinishChange(createGalaxy);
        structureFolder.add(params, 'armTightness', 1, 15, 0.1).name('旋臂紧密度').onFinishChange(createGalaxy);
        structureFolder.add(params, 'armWidth', 0.1, 5, 0.1).name('旋臂宽度').onFinishChange(createGalaxy);
        
        const bloomFolder = gui.addFolder('辉光效果 (Bloom)');
        bloomFolder.add(params, 'bloomThreshold', 0, 1, 0.01).name('辉光-阈值').onChange(v => bloomPass.threshold = v);
        bloomFolder.add(params, 'bloomStrength', 0, 3, 0.01).name('辉光-强度').onChange(v => bloomPass.strength = v);
        bloomFolder.add(params, 'bloomRadius', 0, 1, 0.01).name('辉光-半径').onChange(v => bloomPass.radius = v);
        
        const fogFolder = gui.addFolder('雾气效果 (Fog)');
        fogFolder.add(params, 'fogOpacity', 0, 1, 0.01).name('雾气-不透明度').onChange(v => fogMaterial.opacity = v);
        fogFolder.add(params, 'fogSize', 1, 20, 1).name('雾气-尺寸').onChange(v => fogMaterial.size = v);

        // --- 初始化 ---
        createGalaxy(); // 首次生成

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            sun.rotation.y += 0.005;
            galaxyContainer.rotation.y -= 0.0005;

            // ... (行星动画逻辑保持不变) ...
            planetsGroup.children.forEach(planet => {
                const { radius } = planet.userData;
                const speed = 0.5 / (radius + 1);
                planet.userData.angle += speed * 0.02;
                planet.position.x = radius * Math.cos(planet.userData.angle);
                planet.position.z = radius * Math.sin(planet.userData.angle);
                const waveAmplitude = 1.8, waveFrequency = 0.4;
                planet.position.y = waveAmplitude * Math.sin(waveFrequency * radius + planet.userData.angle);
            });

            controls.update();
            composer.render();
        }

        window.addEventListener('resize', () => { /* ... (窗口自适应逻辑不变) ... */
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
