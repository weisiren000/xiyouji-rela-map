<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 密度函数引力场</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            text-shadow: 0 0 5px #fff;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="info">密度函数引力场 - 可用鼠标交互</div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 场景、相机和渲染器设置 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 45, 65);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- 鼠标控制器 ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 200;

        // --- 光照设置 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffd580, 2, 250);
        scene.add(pointLight);

        // --- 创建中心恒星 ---
        const sunGeometry = new THREE.SphereGeometry(2.5, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffd580 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);
        
        // --- 创建星系 (基于密度函数的对数螺线分布) ---
        const galaxyGroup = new THREE.Group();
        const planetCount = 3500; // 适当增加粒子数以更好地体现密度
        
        // 星系参数
        const galaxyRadius = 50.0; // 星系最大半径
        const numArms = 3; // 旋臂数量
        const armTightness = 4.0; // 旋臂缠绕紧密程度，值越大越紧
        const armWidth = 0.5; // 旋臂的“模糊”或“宽度”

        // 正弦波扰动参数
        const waveAmplitude = 1.8;
        const waveFrequency = 0.4;
        
        const maxEmissiveIntensity = 0.7;

        for (let i = 0; i < planetCount; i++) {
            // --- 核心算法：基于密度函数生成位置 ---
            
            // 1. 半径 (r): 使用幂函数(Math.pow)让粒子更集中于中心，符合密度向外递减的规律
            const r = Math.pow(Math.random(), 2) * galaxyRadius;

            // 2. 角度 (angle): 计算粒子所属的基础旋臂角度
            //    - `Math.log(r + 1)` 是对数螺线的核心
            //    - `* armTightness` 控制缠绕紧密度
            //    - `armIndex * ...` 将粒子分布到不同旋臂
            const armIndex = Math.floor(Math.random() * numArms);
            let angle = Math.log(r + 1) * armTightness + (armIndex * 2 * Math.PI / numArms);

            // 3. 增加随机性: 在基础旋臂周围添加随机偏移，形成有宽度的、模糊的旋臂，而不是一条线
            const randomOffset = (Math.random() - 0.5) * armWidth / (r * 0.1 + 1); // 越往外越发散
            angle += randomOffset;

            // 基础螺旋位置
            const x = r * Math.cos(angle);
            const z = r * Math.sin(angle);
            
            // 添加正弦波扰动到Y轴
            const y = waveAmplitude * Math.sin(waveFrequency * r + angle);

            const planetSize = Math.random() * 0.12 + 0.05;
            const planetGeometry = new THREE.SphereGeometry(planetSize, 16, 16);

            // 发光强度渐变 (基于半径)
            const intensityFactor = 1.0 - (r / galaxyRadius);
            const emissiveIntensity = maxEmissiveIntensity * Math.pow(intensityFactor, 2);

            const planetMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color(Math.random(), Math.random(), Math.random()),
                metalness: 0.3,
                roughness: 0.5,
                emissive: new THREE.Color(0xffffff),
                emissiveIntensity: emissiveIntensity
            });

            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            planet.position.set(x, y, z);
            
            planet.userData = {
                radius: r, // 使用实际生成的半径r
                angle: angle
            };

            galaxyGroup.add(planet);
        }
        scene.add(galaxyGroup);
        
        // --- 创建背景星空 ---
        const starVertices = [];
        for (let i = 0; i < 10000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            starVertices.push(x, y, z);
        }
        const starGeometry = new THREE.BufferGeometry();
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, transparent: true, opacity: 0.8 });
        const starField = new THREE.Points(starGeometry, starMaterial);
        scene.add(starField);

        // --- 后期处理：辉光效果 ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.0;
        bloomPass.radius = 0.5;
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            sun.rotation.y += 0.005;

            galaxyGroup.children.forEach(planet => {
                const { radius } = planet.userData;
                const baseSpeed = 0.5;
                const speed = baseSpeed / (radius + 1);
                planet.userData.angle += speed * 0.02;

                // 重新计算位置以实现公转
                planet.position.x = planet.userData.radius * Math.cos(planet.userData.angle);
                planet.position.z = planet.userData.radius * Math.sin(planet.userData.angle);
                planet.position.y = waveAmplitude * Math.sin(waveFrequency * planet.userData.radius + planet.userData.angle);
            });

            controls.update();
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
