<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 悬浮预览与点击锁定高亮</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #ffffff;
            font-size: 16px;
            text-shadow: 0 0 5px #000;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">悬浮预览 (蓝色), 点击锁定 (白色)</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';

    // --- 核心变量 ---
    let scene, camera, renderer, controls, composer;
    let hoverOutlinePass, selectedOutlinePass; // 两个描边通道
    let interactiveObjects = [];
    let selectedObject = null; // 用于存储被点击锁定的物体

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(); 
    
    // --- 初始化 ---
    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a2a3a);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 8, 12);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
        for (let i = 0; i < 20; i++) {
            const material = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                roughness: 0.5,
                metalness: 0.5
            });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20);
            cube.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
            scene.add(cube);
            interactiveObjects.push(cube);
        }

        setupPostProcessing();

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('pointermove', onPointerMove, false);
        document.addEventListener('pointerdown', onPointerDown, false);
    }

    // --- 设置后期处理 ---
    function setupPostProcessing() {
        composer = new EffectComposer(renderer);
        
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // 1. 悬浮高亮通道 (蓝色)
        hoverOutlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
        hoverOutlinePass.edgeStrength = 5.0;
        hoverOutlinePass.edgeGlow = 0.7;
        hoverOutlinePass.edgeThickness = 1.5;
        hoverOutlinePass.visibleEdgeColor.set('#00aaff'); // 设置为蓝色
        hoverOutlinePass.hiddenEdgeColor.set('#00aaff');
        composer.addPass(hoverOutlinePass);
        
        // 2. 点击锁定高亮通道 (白色)
        selectedOutlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
        selectedOutlinePass.edgeStrength = 8.0;
        selectedOutlinePass.edgeGlow = 1.0;
        selectedOutlinePass.edgeThickness = 2.0;
        selectedOutlinePass.visibleEdgeColor.set('#ffffff'); // 设置为白色
        selectedOutlinePass.hiddenEdgeColor.set('#ffffff');
        composer.addPass(selectedOutlinePass);

        // 抗锯齿通道
        const fxaaPass = new ShaderPass(FXAAShader);
        fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * renderer.getPixelRatio());
        fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * renderer.getPixelRatio());
        composer.addPass(fxaaPass);
    }

    // --- 事件处理 ---
    function onPointerMove(event) {
        if (event.buttons > 0) return;

        updateMousePosition(event);
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(interactiveObjects, false);

        if (intersects.length > 0) {
            const hoveredObj = intersects[0].object;
            // 如果悬浮的物体不是当前锁定的物体，才显示蓝色预览
            if(hoveredObj !== selectedObject) {
                 hoverOutlinePass.selectedObjects = [hoveredObj];
            } else {
                 hoverOutlinePass.selectedObjects = [];
            }
        } else {
            hoverOutlinePass.selectedObjects = [];
        }
    }

    function onPointerDown(event) {
        updateMousePosition(event);

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(interactiveObjects, false);

        if (intersects.length > 0) {
            const clickedObj = intersects[0].object;
            // 如果点击了新物体，就更新锁定的物体
            selectedObject = clickedObj; 
            selectedOutlinePass.selectedObjects = [selectedObject];
            // 清除蓝色预览，因为现在它被白色锁定了
            hoverOutlinePass.selectedObjects = []; 
        } else {
            // 如果点击了背景，就取消所有锁定
            selectedObject = null;
            selectedOutlinePass.selectedObjects = [];
        }
    }
    
    // --- 辅助函数 ---
    function updateMousePosition(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        mouse.x = (x / rect.width) * 2 - 1;
        mouse.y = - (y / rect.height) * 2 + 1;
    }


    // --- 窗口大小调整 ---
    function onWindowResize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        composer.setSize(width, height);
        // ... (省略fxaa更新代码以保持简洁)
    }

    // --- 动画循环 ---
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        composer.render();
    }

    init();
    animate();
    </script>
</body>
</html>
