<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>西游记银河系关系图谱 - 星图风格</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            color: #eee;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .ui-panel {
            position: absolute;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(0, 0, 0, .7);
            border-radius: 12px;
            border: 1px solid rgba(255, 120, 50, .3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, .5);
            z-index: 10;
            padding: 15px;
            color: #eee;
            font-family: 'Inter', sans-serif;
        }

        #instructions-container {
            top: 20px;
            left: 20px;
            max-width: 280px;
        }

        #instruction-title {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 8px;
            color: #FF7832;
        }

        #theme-selector {
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: 180px;
        }

        #theme-selector-title {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 2px;
            color: #FF7832;
        }

        .theme-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .theme-button {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, .3);
            cursor: pointer;
            transition: transform .2s, border-color .2s, box-shadow .2s;
            outline: none;
            overflow: hidden;
        }

        .theme-button:hover, .theme-button:focus {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, .7);
        }

        .theme-button.active {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, .9);
            box-shadow: 0 0 15px rgba(255, 120, 50, .8);
        }

        #theme-1 { background: linear-gradient(45deg, #FFD700, #FF8C00, #FF4500, #DC143C); }
        #theme-2 { background: linear-gradient(45deg, #4F46E5, #7C3AED, #C026D3, #DB2777); }
        #theme-3 { background: linear-gradient(45deg, #10B981, #A3E635, #FACC15, #FB923C); }
        #theme-4 { background: linear-gradient(45deg, #EC4899, #8B5CF6, #6366F1, #3B82F6); }

        #density-controls {
            margin-top: 15px;
        }

        .density-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .density-slider {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 255, 255, .2);
            outline: none;
            -webkit-appearance: none;
        }

        .density-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #FF7832;
            cursor: pointer;
        }

        .density-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #FF7832;
            cursor: pointer;
            border: none;
        }

        #control-buttons {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
            background: rgba(0, 0, 0, .6);
            padding: 12px 18px;
            border-radius: 12px;
            border: 1px solid rgba(255, 120, 50, .3);
            backdrop-filter: blur(10px);
        }

        .control-button {
            background: rgba(255, 120, 50, .2);
            color: #eee;
            border: 1px solid rgba(255, 150, 50, .3);
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            white-space: nowrap;
            min-width: 90px;
            text-align: center;
            font-family: 'Inter', sans-serif;
        }

        .control-button:hover, .control-button:focus {
            background: rgba(255, 120, 50, .4);
            outline: none;
            transform: translateY(-1px);
        }

        .control-button:active {
            background: rgba(255, 120, 50, .6);
            transform: scale(0.95);
        }

        .control-button.active {
            background: rgba(255, 120, 50, .6);
            border-color: rgba(255, 150, 50, .8);
            box-shadow: 0 0 10px rgba(255, 120, 50, .4);
        }

        @media (max-width: 768px) {
            #instructions-container {
                max-width: calc(100% - 40px);
                font-size: 13px;
                top: 10px;
                left: 10px;
            }

            #theme-selector {
                top: auto;
                bottom: 100px;
                right: 10px;
                max-width: 140px;
            }

            .theme-button {
                width: 32px;
                height: 32px;
            }

            #control-buttons {
                bottom: 10px;
                gap: 10px;
                padding: 8px 12px;
                flex-wrap: wrap;
                justify-content: center;
            }

            .control-button {
                padding: 8px 12px;
                font-size: 12px;
                min-width: 70px;
            }
        }

        @media (max-width: 400px) {
            #theme-selector {
                flex-direction: column;
                align-items: center;
                max-width: none;
                width: calc(100% - 20px);
                left: 10px;
                right: 10px;
                bottom: 75px;
            }

            .theme-grid {
                grid-template-columns: repeat(4, 1fr);
                width: 100%;
                justify-items: center;
            }

            #density-controls {
                width: 80%;
                margin-top: 15px;
            }

            #control-buttons {
                width: calc(100% - 20px);
                justify-content: space-around;
            }
        }
    </style>
</head>
<body>
    <div id="instructions-container" class="ui-panel">
        <div id="instruction-title">西游记关系图谱</div>
        <div>点击角色节点创建能量脉冲，拖拽旋转视角。体验银河系中的西游记世界。</div>
    </div>

    <div id="theme-selector" class="ui-panel">
        <div id="theme-selector-title">西游记主题</div>
        <div class="theme-grid">
            <button class="theme-button" id="theme-1" data-theme="0" aria-label="天庭金辉"></button>
            <button class="theme-button active" id="theme-2" data-theme="1" aria-label="佛光普照"></button>
            <button class="theme-button" id="theme-3" data-theme="2" aria-label="妖魔鬼怪"></button>
            <button class="theme-button" id="theme-4" data-theme="3" aria-label="取经路上"></button>
        </div>
        <div id="density-controls">
            <div class="density-label"><span>密度</span><span id="density-value">100%</span></div>
            <input type="range" min="20" max="100" value="100" class="density-slider" id="density-slider" aria-label="角色密度">
        </div>
    </div>

    <div id="control-buttons">
        <button id="change-formation-btn" class="control-button">布局</button>
        <button id="pause-play-btn" class="control-button">暂停</button>
        <button id="reset-camera-btn" class="control-button">重置视角</button>
    </div>

    <canvas id="xiyouji-canvas"></canvas>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        const config = {
            paused: false,
            activePaletteIndex: 1,
            currentFormation: 0,
            numFormations: 4,
            densityFactor: 1
        };

        // 西游记主题配色 - 完全采用星图的配色系统
        const xiyoujiPalettes = [
            // 天庭金辉
            [new THREE.Color(0xFFD700), new THREE.Color(0xFF8C00), new THREE.Color(0xFF4500), new THREE.Color(0xDC143C), new THREE.Color(0xB8860B)],
            // 佛光普照
            [new THREE.Color(0x4F46E5), new THREE.Color(0x7C3AED), new THREE.Color(0xC026D3), new THREE.Color(0xDB2777), new THREE.Color(0x8B5CF6)],
            // 妖魔鬼怪
            [new THREE.Color(0x10B981), new THREE.Color(0xA3E635), new THREE.Color(0xFACC15), new THREE.Color(0xFB923C), new THREE.Color(0x4ADE80)],
            // 取经路上
            [new THREE.Color(0xEC4899), new THREE.Color(0x8B5CF6), new THREE.Color(0x6366F1), new THREE.Color(0x3B82F6), new THREE.Color(0xA855F7)]
        ];

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1200);
        camera.position.set(0, 5, 22);

        const canvasElement = document.getElementById('xiyouji-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas: canvasElement, antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000);
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        // 创建星空背景 - 完全采用星图的算法
        function createStarfield() {
            const count = 5000, pos = [];
            for (let i = 0; i < count; i++) {
                const r = THREE.MathUtils.randFloat(40, 120);
                const phi = Math.acos(THREE.MathUtils.randFloatSpread(2));
                const theta = THREE.MathUtils.randFloat(0, Math.PI * 2);
                pos.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.15,
                sizeAttenuation: true,
                depthWrite: false,
                opacity: 0.8,
                transparent: true
            });
            return new THREE.Points(geo, mat);
        }
        const starField = createStarfield();
        scene.add(starField);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.5;
        controls.minDistance = 5;
        controls.maxDistance = 100;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.15;
        controls.enablePan = false;

        // 后处理管线 - 完全采用星图的设置
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.68);
        composer.addPass(bloomPass);

        const filmPass = new FilmPass(0.35, 0.55, 2048, false);
        composer.addPass(filmPass);

        composer.addPass(new OutputPass());

        // 脉冲系统 - 完全采用星图的脉冲系统
        const pulseUniforms = {
            uTime: { value: 0.0 },
            uPulsePositions: { value: [new THREE.Vector3(1e3, 1e3, 1e3), new THREE.Vector3(1e3, 1e3, 1e3), new THREE.Vector3(1e3, 1e3, 1e3)] },
            uPulseTimes: { value: [-1e3, -1e3, -1e3] },
            uPulseColors: { value: [new THREE.Color(1, 1, 1), new THREE.Color(1, 1, 1), new THREE.Color(1, 1, 1)] },
            uPulseSpeed: { value: 15.0 },
            uBaseNodeSize: { value: 0.5 },
            uActivePalette: { value: 0 }
        };

        // 噪声函数 - 完全采用星图的噪声算法
        const noiseFunctions = `
        vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}
        vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}
        vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
        vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}
        float snoise(vec3 v){
            const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);
            vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);
            vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);
            vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);
            vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));
            float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;
            vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);
            vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);
            vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;
            vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;
            vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);
            vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
            p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);
            m*=m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
        }
        float fbm(vec3 p,float time){
            float value=0.0;float amplitude=0.5;float frequency=1.0;int octaves=3;
            for(int i=0;i<octaves;i++){
                value+=amplitude*snoise(p*frequency+time*0.2*frequency);
                amplitude*=0.5;frequency*=2.0;
            }
            return value;
        }`;

        // 节点着色器 - 完全采用星图的高级着色器
        const nodeShader = {
            vertexShader: `${noiseFunctions}
            attribute float nodeSize;attribute float nodeType;attribute vec3 nodeColor;attribute vec3 connectionIndices;attribute float distanceFromRoot;
            uniform float uTime;uniform vec3 uPulsePositions[3];uniform float uPulseTimes[3];uniform float uPulseSpeed;uniform float uBaseNodeSize;
            varying vec3 vColor;varying float vNodeType;varying vec3 vPosition;varying float vPulseIntensity;varying float vDistanceFromRoot;

            float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) {
                if (pulseTime < 0.0) return 0.0;
                float timeSinceClick = uTime - pulseTime;
                if (timeSinceClick < 0.0 || timeSinceClick > 3.0) return 0.0;

                float pulseRadius = timeSinceClick * uPulseSpeed;
                float distToClick = distance(worldPos, pulsePos);
                float pulseThickness = 2.0;
                float waveProximity = abs(distToClick - pulseRadius);

                return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(3.0, 0.0, timeSinceClick);
            }

            void main() {
                vNodeType = nodeType;
                vColor = nodeColor;
                vDistanceFromRoot = distanceFromRoot;

                vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz;
                vPosition = worldPos;

                float totalPulseIntensity = 0.0;
                for (int i = 0; i < 3; i++) {
                    totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);
                }
                vPulseIntensity = min(totalPulseIntensity, 1.0);

                float timeScale = 0.5 + 0.5 * sin(uTime * 0.8 + distanceFromRoot * 0.2);
                float baseSize = nodeSize * (0.8 + 0.2 * timeScale);
                float pulseSize = baseSize * (1.0 + vPulseIntensity * 2.0);

                vec3 modifiedPosition = position;
                if (nodeType > 0.5) {
                    float noise = fbm(position * 0.1, uTime * 0.1);
                    modifiedPosition += normal * noise * 0.2;
                }

                vec4 mvPosition = modelViewMatrix * vec4(modifiedPosition, 1.0);
                gl_PointSize = pulseSize * uBaseNodeSize * (800.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }`,

            fragmentShader: `
            uniform float uTime;uniform vec3 uPulseColors[3];uniform int uActivePalette;
            varying vec3 vColor;varying float vNodeType;varying vec3 vPosition;varying float vPulseIntensity;varying float vDistanceFromRoot;

            void main() {
                vec2 center = 2.0 * gl_PointCoord - 1.0;
                float dist = length(center);
                if (dist > 1.0) discard;

                float glowStrength = 1.0 - smoothstep(0.0, 1.0, dist);
                glowStrength = pow(glowStrength, 1.4);

                vec3 baseColor = vColor * (0.8 + 0.2 * sin(uTime * 0.5 + vDistanceFromRoot * 0.3));
                vec3 finalColor = baseColor;

                if (vPulseIntensity > 0.0) {
                    vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.3);
                    finalColor = mix(baseColor, pulseColor, vPulseIntensity);
                    finalColor *= (1.0 + vPulseIntensity * 0.7);
                }

                float alpha = glowStrength * (0.9 - 0.5 * dist);

                float camDistance = length(vPosition - cameraPosition);
                float distanceFade = smoothstep(80.0, 10.0, camDistance);

                if (vNodeType > 0.5) {
                    alpha *= 0.85;
                } else {
                    finalColor *= 1.2;
                }

                gl_FragColor = vec4(finalColor, alpha * distanceFade);
            }`
        };

        // 西游记角色数据 - 优化的数据结构
        const xiyoujiCharacters = [
            { name: '孙悟空', type: 0, importance: 1.0, celestial: 'earth', aliases: ['美猴王', '齐天大圣'] },
            { name: '唐僧', type: 0, importance: 0.9, celestial: 'earth', aliases: ['玄奘', '三藏法师'] },
            { name: '猪八戒', type: 0, importance: 0.8, celestial: 'earth', aliases: ['猪悟能', '天蓬元帅'] },
            { name: '沙僧', type: 0, importance: 0.7, celestial: 'earth', aliases: ['沙悟净', '卷帘大将'] },
            { name: '白龙马', type: 0, importance: 0.6, celestial: 'earth', aliases: ['敖烈', '三太子'] },
            { name: '如来佛祖', type: 1, importance: 1.0, celestial: 'mercury', aliases: ['释迦牟尼', '佛祖'] },
            { name: '观音菩萨', type: 1, importance: 0.95, celestial: 'venus', aliases: ['观世音', '南海观音'] },
            { name: '玉皇大帝', type: 1, importance: 1.0, celestial: 'sun', aliases: ['昊天上帝', '天帝'] },
            { name: '太上老君', type: 1, importance: 0.9, celestial: 'uranus', aliases: ['老子', '道德天尊'] },
            { name: '二郎神', type: 1, importance: 0.8, celestial: 'saturn', aliases: ['杨戬', '显圣真君'] },
            { name: '哪吒', type: 1, importance: 0.75, celestial: 'saturn', aliases: ['三太子'] },
            { name: '牛魔王', type: 2, importance: 0.85, celestial: 'mars', aliases: ['大力王'] },
            { name: '铁扇公主', type: 2, importance: 0.75, celestial: 'mars', aliases: ['罗刹女'] },
            { name: '红孩儿', type: 2, importance: 0.7, celestial: 'mars', aliases: ['圣婴大王'] },
            { name: '白骨精', type: 2, importance: 0.65, celestial: 'mars', aliases: ['白骨夫人'] },
            { name: '金角大王', type: 2, importance: 0.6, celestial: 'jupiter', aliases: [] },
            { name: '银角大王', type: 2, importance: 0.6, celestial: 'jupiter', aliases: [] },
            { name: '文殊菩萨', type: 1, importance: 0.8, celestial: 'mercury', aliases: ['文殊师利'] },
            { name: '李天王', type: 1, importance: 0.7, celestial: 'saturn', aliases: ['托塔天王', '李靖'] },
            { name: '太白金星', type: 1, importance: 0.65, celestial: 'saturn', aliases: [] },
            { name: '镇元大仙', type: 3, importance: 0.6, celestial: 'neptune', aliases: ['地仙之祖'] }
        ];

        // 关系数据
        const relationships = [
            { from: 1, to: 0, type: 'master_disciple', strength: 0.9 },
            { from: 1, to: 2, type: 'master_disciple', strength: 0.8 },
            { from: 1, to: 3, type: 'master_disciple', strength: 0.85 },
            { from: 1, to: 4, type: 'master_disciple', strength: 0.7 },
            { from: 0, to: 2, type: 'fellow_disciple', strength: 0.7 },
            { from: 0, to: 3, type: 'fellow_disciple', strength: 0.8 },
            { from: 2, to: 3, type: 'fellow_disciple', strength: 0.75 },
            { from: 11, to: 12, type: 'family', strength: 0.8 },
            { from: 11, to: 13, type: 'family', strength: 0.9 },
            { from: 12, to: 13, type: 'family', strength: 0.9 },
            { from: 0, to: 14, type: 'enemy', strength: 0.9 },
            { from: 0, to: 11, type: 'enemy', strength: 0.8 },
            { from: 0, to: 15, type: 'enemy', strength: 0.7 },
            { from: 0, to: 16, type: 'enemy', strength: 0.7 },
            { from: 7, to: 9, type: 'superior', strength: 0.8 },
            { from: 7, to: 10, type: 'superior', strength: 0.75 },
            { from: 7, to: 18, type: 'superior', strength: 0.7 },
            { from: 5, to: 6, type: 'buddhist', strength: 0.9 },
            { from: 5, to: 17, type: 'buddhist', strength: 0.8 }
        ];

        // 天体配置
        const celestialBodies = {
            sun: { radius: 0, name: '太阳中心' },
            mercury: { radius: 8, name: '水星-佛界' },
            venus: { radius: 12, name: '金星-观音净土' },
            earth: { radius: 16, name: '地球-取经团队' },
            mars: { radius: 20, name: '火星-妖魔世界' },
            jupiter: { radius: 24, name: '木星-妖王联盟' },
            saturn: { radius: 28, name: '土星-天庭众神' },
            uranus: { radius: 32, name: '天王星-道教仙人' },
            neptune: { radius: 36, name: '海王星-其他角色' }
        };

        // 节点系统 - 完全采用星图的节点系统
        class NodeSystem {
            constructor() {
                this.nodeCount = Math.floor(xiyoujiCharacters.length * config.densityFactor);
                this.positions = new Float32Array(this.nodeCount * 3);
                this.colors = new Float32Array(this.nodeCount * 3);
                this.sizes = new Float32Array(this.nodeCount);
                this.types = new Float32Array(this.nodeCount);
                this.connectionIndices = new Float32Array(this.nodeCount * 3);
                this.distancesFromRoot = new Float32Array(this.nodeCount);
                this.geometry = new THREE.BufferGeometry();
                this.material = null;
                this.points = null;
                this.init();
            }

            init() {
                this.generateNodes();
                this.createGeometry();
                this.createMaterial();
                this.createPoints();
            }

            generateNodes() {
                for (let i = 0; i < this.nodeCount; i++) {
                    const charIndex = i % xiyoujiCharacters.length;
                    const character = xiyoujiCharacters[charIndex];

                    // 位置 - 银河系螺旋布局
                    const celestialBody = celestialBodies[character.celestial];
                    const baseRadius = celestialBody.radius;
                    const arms = 4;
                    const armIndex = i % arms;
                    const spiralAngle = (armIndex * Math.PI * 0.5) + (i / this.nodeCount) * Math.PI * 6;
                    const radiusOffset = (1 - character.importance) * 3;
                    const finalRadius = baseRadius + radiusOffset;

                    this.positions[i * 3] = Math.cos(spiralAngle) * finalRadius;
                    this.positions[i * 3 + 1] = Math.sin(i * 0.1) * 2;
                    this.positions[i * 3 + 2] = Math.sin(spiralAngle) * finalRadius;

                    // 颜色
                    const palette = xiyoujiPalettes[config.activePaletteIndex];
                    const color = palette[character.type % palette.length];
                    this.colors[i * 3] = color.r;
                    this.colors[i * 3 + 1] = color.g;
                    this.colors[i * 3 + 2] = color.b;

                    // 大小
                    this.sizes[i] = 0.8 + character.importance * 1.2;

                    // 类型
                    this.types[i] = character.type;

                    // 连接索引
                    const connections = relationships.filter(rel => rel.from === charIndex || rel.to === charIndex);
                    for (let j = 0; j < 3; j++) {
                        this.connectionIndices[i * 3 + j] = connections[j] ? (connections[j].from === charIndex ? connections[j].to : connections[j].from) : -1;
                    }

                    // 距离根节点
                    this.distancesFromRoot[i] = i * 0.1;
                }
            }

            createGeometry() {
                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('nodeColor', new THREE.BufferAttribute(this.colors, 3));
                this.geometry.setAttribute('nodeSize', new THREE.BufferAttribute(this.sizes, 1));
                this.geometry.setAttribute('nodeType', new THREE.BufferAttribute(this.types, 1));
                this.geometry.setAttribute('connectionIndices', new THREE.BufferAttribute(this.connectionIndices, 3));
                this.geometry.setAttribute('distanceFromRoot', new THREE.BufferAttribute(this.distancesFromRoot, 1));
            }

            createMaterial() {
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        ...pulseUniforms,
                        uActivePalette: { value: config.activePaletteIndex }
                    },
                    vertexShader: nodeShader.vertexShader,
                    fragmentShader: nodeShader.fragmentShader,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
            }

            createPoints() {
                this.points = new THREE.Points(this.geometry, this.material);
                scene.add(this.points);
            }

            updatePalette(paletteIndex) {
                const palette = xiyoujiPalettes[paletteIndex];
                for (let i = 0; i < this.nodeCount; i++) {
                    const charIndex = i % xiyoujiCharacters.length;
                    const character = xiyoujiCharacters[charIndex];
                    const color = palette[character.type % palette.length];
                    this.colors[i * 3] = color.r;
                    this.colors[i * 3 + 1] = color.g;
                    this.colors[i * 3 + 2] = color.b;
                }
                this.geometry.attributes.nodeColor.needsUpdate = true;
                this.material.uniforms.uActivePalette.value = paletteIndex;
            }

            updateDensity(densityFactor) {
                const newNodeCount = Math.floor(xiyoujiCharacters.length * densityFactor);
                if (newNodeCount !== this.nodeCount) {
                    scene.remove(this.points);
                    this.nodeCount = newNodeCount;
                    this.positions = new Float32Array(this.nodeCount * 3);
                    this.colors = new Float32Array(this.nodeCount * 3);
                    this.sizes = new Float32Array(this.nodeCount);
                    this.types = new Float32Array(this.nodeCount);
                    this.connectionIndices = new Float32Array(this.nodeCount * 3);
                    this.distancesFromRoot = new Float32Array(this.nodeCount);
                    this.generateNodes();
                    this.createGeometry();
                    this.createPoints();
                }
            }

            applyFormation(formationIndex) {
                switch(formationIndex) {
                    case 0: // 银河系螺旋
                        this.applyGalaxyFormation();
                        break;
                    case 1: // 九重天分层
                        this.applyNineHeavensFormation();
                        break;
                    case 2: // 取经路线
                        this.applyJourneyFormation();
                        break;
                    case 3: // 势力阵营
                        this.applyFactionsFormation();
                        break;
                }
                this.geometry.attributes.position.needsUpdate = true;
            }

            applyGalaxyFormation() {
                for (let i = 0; i < this.nodeCount; i++) {
                    const charIndex = i % xiyoujiCharacters.length;
                    const character = xiyoujiCharacters[charIndex];
                    const celestialBody = celestialBodies[character.celestial];
                    const baseRadius = celestialBody.radius;
                    const arms = 4;
                    const armIndex = i % arms;
                    const spiralAngle = (armIndex * Math.PI * 0.5) + (i / this.nodeCount) * Math.PI * 6;
                    const radiusOffset = (1 - character.importance) * 3;
                    const finalRadius = baseRadius + radiusOffset;

                    this.positions[i * 3] = Math.cos(spiralAngle) * finalRadius;
                    this.positions[i * 3 + 1] = Math.sin(i * 0.1) * 2;
                    this.positions[i * 3 + 2] = Math.sin(spiralAngle) * finalRadius;
                }
            }

            applyNineHeavensFormation() {
                const layers = 9;
                const layerHeight = 8;

                for (let i = 0; i < this.nodeCount; i++) {
                    const charIndex = i % xiyoujiCharacters.length;
                    const character = xiyoujiCharacters[charIndex];
                    const layer = Math.floor((1 - character.importance) * layers);
                    const positionInLayer = i % Math.ceil(this.nodeCount / layers);
                    const nodesInLayer = Math.ceil(this.nodeCount / layers);

                    const angle = (positionInLayer / nodesInLayer) * Math.PI * 2;
                    const radius = 5 + layer * 3;
                    const height = (layers - layer - 1) * layerHeight - (layers * layerHeight / 2);

                    this.positions[i * 3] = Math.cos(angle) * radius;
                    this.positions[i * 3 + 1] = height;
                    this.positions[i * 3 + 2] = Math.sin(angle) * radius;
                }
            }

            applyJourneyFormation() {
                const pathLength = 60;
                const spiralRadius = 15;

                for (let i = 0; i < this.nodeCount; i++) {
                    const t = i / (this.nodeCount - 1);
                    const angle = t * Math.PI * 4;
                    const z = (t - 0.5) * pathLength;

                    this.positions[i * 3] = Math.cos(angle) * spiralRadius * (1 - t * 0.3);
                    this.positions[i * 3 + 1] = Math.sin(angle) * spiralRadius * (1 - t * 0.3);
                    this.positions[i * 3 + 2] = z;
                }
            }

            applyFactionsFormation() {
                const factionCenters = [
                    new THREE.Vector3(0, 0, 0),    // 主角
                    new THREE.Vector3(20, 10, 0),  // 神仙
                    new THREE.Vector3(0, -10, 0),  // 妖魔
                    new THREE.Vector3(0, 10, 20)   // 其他
                ];

                for (let i = 0; i < this.nodeCount; i++) {
                    const charIndex = i % xiyoujiCharacters.length;
                    const character = xiyoujiCharacters[charIndex];
                    const factionIndex = Math.min(character.type, factionCenters.length - 1);
                    const center = factionCenters[factionIndex];

                    const angle = (i / this.nodeCount) * Math.PI * 2;
                    const radius = 3 + Math.random() * 5;

                    this.positions[i * 3] = center.x + Math.cos(angle) * radius;
                    this.positions[i * 3 + 1] = center.y + (Math.random() - 0.5) * 4;
                    this.positions[i * 3 + 2] = center.z + Math.sin(angle) * radius;
                }
            }
        }

        // 初始化系统
        const nodeSystem = new NodeSystem();

        // 交互系统
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onCanvasClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            raycaster.params.Points.threshold = 2;

            const intersects = raycaster.intersectObject(nodeSystem.points);
            if (intersects.length > 0) {
                const clickPosition = intersects[0].point;
                createPulse(clickPosition);

                // 显示角色信息
                const index = intersects[0].index;
                const charIndex = index % xiyoujiCharacters.length;
                const character = xiyoujiCharacters[charIndex];
                showCharacterInfo(character);
            }
        }

        function createPulse(position) {
            for (let i = 0; i < 3; i++) {
                if (pulseUniforms.uPulseTimes.value[i] < pulseUniforms.uTime.value - 3) {
                    pulseUniforms.uPulsePositions.value[i].copy(position);
                    pulseUniforms.uPulseTimes.value[i] = pulseUniforms.uTime.value;
                    pulseUniforms.uPulseColors.value[i] = xiyoujiPalettes[config.activePaletteIndex][0];
                    break;
                }
            }
        }

        function showCharacterInfo(character) {
            const instructionTitle = document.getElementById('instruction-title');
            const instructionContainer = document.getElementById('instructions-container');

            instructionTitle.textContent = character.name;
            instructionContainer.innerHTML = `
                <div id="instruction-title">${character.name}</div>
                <div><strong>类型:</strong> ${getTypeDisplayName(character.type)}</div>
                <div><strong>天体:</strong> ${celestialBodies[character.celestial].name}</div>
                <div><strong>重要性:</strong> ${(character.importance * 100).toFixed(0)}%</div>
                <div><strong>别名:</strong> ${character.aliases.join(', ') || '无'}</div>
                <button onclick="resetInstructions()" style="margin-top: 10px; background: rgba(255, 120, 50, .6); color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">返回</button>
            `;
        }

        function getTypeDisplayName(type) {
            const names = ['主角', '神仙', '妖魔', '其他'];
            return names[type] || '未知';
        }

        window.resetInstructions = function() {
            const instructionContainer = document.getElementById('instructions-container');
            instructionContainer.innerHTML = `
                <div id="instruction-title">西游记关系图谱</div>
                <div>点击角色节点创建能量脉冲，拖拽旋转视角。体验银河系中的西游记世界。</div>
            `;
        };

        // 事件监听
        canvasElement.addEventListener('click', onCanvasClick);

        // UI控制
        document.getElementById('change-formation-btn').addEventListener('click', () => {
            config.currentFormation = (config.currentFormation + 1) % config.numFormations;
            nodeSystem.applyFormation(config.currentFormation);

            const formationNames = ['银河系螺旋', '九重天分层', '取经路线', '势力阵营'];
            document.getElementById('change-formation-btn').textContent = formationNames[config.currentFormation];
        });

        document.getElementById('pause-play-btn').addEventListener('click', () => {
            config.paused = !config.paused;
            controls.autoRotate = !config.paused;
            document.getElementById('pause-play-btn').textContent = config.paused ? '播放' : '暂停';
        });

        document.getElementById('reset-camera-btn').addEventListener('click', () => {
            camera.position.set(0, 5, 22);
            controls.target.set(0, 0, 0);
            controls.update();
        });

        // 主题切换
        document.querySelectorAll('.theme-button').forEach((button, index) => {
            button.addEventListener('click', () => {
                config.activePaletteIndex = index;
                nodeSystem.updatePalette(index);

                document.querySelectorAll('.theme-button').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
            });
        });

        // 密度控制
        document.getElementById('density-slider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            config.densityFactor = value / 100;
            nodeSystem.updateDensity(config.densityFactor);
            document.getElementById('density-value').textContent = value + '%';
        });

        // 渲染循环
        function animate() {
            requestAnimationFrame(animate);

            if (!config.paused) {
                const time = performance.now() * 0.001;
                pulseUniforms.uTime.value = time;

                controls.update();
                composer.render();
            }
        }

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // 启动
        animate();
    </script>
</body>
</html>
