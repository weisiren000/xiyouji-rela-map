<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>西游记银河系关系图谱 Demo</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            color: #eee;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .ui-panel {
            position: absolute;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(0, 0, 0, .7);
            border-radius: 12px;
            border: 1px solid rgba(255, 120, 50, .3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, .5);
            z-index: 10;
            padding: 15px;
            color: #eee;
            font-family: 'Inter', sans-serif;
        }

        #info-panel {
            top: 20px;
            left: 20px;
            max-width: 320px;
            display: none;
            border: 1px solid rgba(255, 215, 0, .4);
        }

        #info-panel h3 {
            color: #FFD700;
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 18px;
        }

        #info-panel p {
            margin: 8px 0;
            font-size: 14px;
            line-height: 1.4;
        }

        .relationship-item {
            margin: 6px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            border-left: 3px solid rgba(255, 120, 50, .6);
        }

        .relation-type {
            color: #FF7832;
            font-weight: 600;
            font-size: 13px;
        }

        .close-btn {
            background: rgba(244, 67, 54, .8);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            margin-top: 12px;
            transition: background 0.2s;
        }

        .close-btn:hover {
            background: rgba(244, 67, 54, 1);
        }

        #theme-selector {
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: 180px;
        }

        #theme-selector-title {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 2px;
            color: #FF7832;
        }

        .theme-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .theme-button {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, .3);
            cursor: pointer;
            transition: transform .2s, border-color .2s, box-shadow .2s;
            outline: none;
            overflow: hidden;
        }

        .theme-button:hover, .theme-button:focus {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, .7);
        }

        .theme-button.active {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, .9);
            box-shadow: 0 0 15px rgba(255, 120, 50, .8);
        }

        #theme-1 { background: linear-gradient(45deg, #FFD700, #FF8C00, #FF4500, #DC143C); }
        #theme-2 { background: linear-gradient(45deg, #4F46E5, #7C3AED, #C026D3, #DB2777); }
        #theme-3 { background: linear-gradient(45deg, #10B981, #A3E635, #FACC15, #FB923C); }
        #theme-4 { background: linear-gradient(45deg, #EC4899, #8B5CF6, #6366F1, #3B82F6); }

        #control-buttons {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
            background: rgba(0, 0, 0, .6);
            padding: 12px 18px;
            border-radius: 12px;
            border: 1px solid rgba(255, 120, 50, .3);
            backdrop-filter: blur(10px);
        }

        .control-button {
            background: rgba(255, 120, 50, .2);
            color: #eee;
            border: 1px solid rgba(255, 150, 50, .3);
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            white-space: nowrap;
            min-width: 90px;
            text-align: center;
            font-family: 'Inter', sans-serif;
        }

        .control-button:hover, .control-button:focus {
            background: rgba(255, 120, 50, .4);
            outline: none;
            transform: translateY(-1px);
        }

        .control-button:active {
            background: rgba(255, 120, 50, .6);
            transform: scale(0.95);
        }

        .control-button.active {
            background: rgba(255, 120, 50, .6);
            border-color: rgba(255, 150, 50, .8);
            box-shadow: 0 0 10px rgba(255, 120, 50, .4);
        }

        #view-mode {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, .6);
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid rgba(255, 120, 50, .3);
            z-index: 10;
            backdrop-filter: blur(10px);
            font-size: 14px;
        }

        #current-mode {
            color: #FF7832;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            #info-panel {
                max-width: calc(100% - 40px);
                font-size: 13px;
                top: 10px;
                left: 10px;
            }

            #theme-selector {
                top: auto;
                bottom: 100px;
                right: 10px;
                max-width: 140px;
            }

            .theme-button {
                width: 32px;
                height: 32px;
            }

            #control-buttons {
                bottom: 10px;
                gap: 10px;
                padding: 8px 12px;
                flex-wrap: wrap;
                justify-content: center;
            }

            .control-button {
                padding: 8px 12px;
                font-size: 12px;
                min-width: 70px;
            }

            #view-mode {
                bottom: 10px;
                right: 10px;
                font-size: 12px;
                padding: 8px 12px;
            }
        }
    </style>
</head>
<body>
    <div id="info-panel" class="ui-panel">
        <h3 id="char-name">角色信息</h3>
        <p><strong>类型:</strong> <span id="char-type"></span></p>
        <p><strong>天体:</strong> <span id="char-celestial"></span></p>
        <p><strong>重要性:</strong> <span id="char-importance"></span></p>
        <p><strong>别名:</strong> <span id="char-aliases"></span></p>
        <div id="relationships"></div>
        <button class="close-btn" onclick="closeInfoPanel()">关闭</button>
    </div>

    <div id="theme-selector" class="ui-panel">
        <div id="theme-selector-title">西游记主题</div>
        <div class="theme-grid">
            <button class="theme-button active" id="theme-1" data-theme="0" aria-label="天庭金辉"></button>
            <button class="theme-button" id="theme-2" data-theme="1" aria-label="佛光普照"></button>
            <button class="theme-button" id="theme-3" data-theme="2" aria-label="妖魔鬼怪"></button>
            <button class="theme-button" id="theme-4" data-theme="3" aria-label="取经路上"></button>
        </div>
    </div>

    <div id="control-buttons">
        <button class="control-button active" onclick="switchLayout('galaxy')">银河系</button>
        <button class="control-button" onclick="switchLayout('nine_heavens')">九重天</button>
        <button class="control-button" onclick="switchLayout('journey')">取经路线</button>
        <button class="control-button" onclick="switchLayout('factions')">势力阵营</button>
        <button class="control-button" onclick="toggleConnections()">连线</button>
        <button class="control-button" onclick="resetView()">重置</button>
    </div>

    <div id="view-mode" class="ui-panel">
        <strong>当前模式:</strong> <span id="current-mode">银河系全景</span>
    </div>

    <canvas id="xiyouji-canvas"></canvas>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // 配置
        const config = {
            paused: false,
            activeTheme: 0,
            currentLayout: 0,
            showConnections: true,
            autoRotate: true
        };

        // 西游记主题配色
        const xiyoujiThemes = [
            // 天庭金辉
            [new THREE.Color(0xFFD700), new THREE.Color(0xFF8C00), new THREE.Color(0xFF4500), new THREE.Color(0xDC143C), new THREE.Color(0xB8860B)],
            // 佛光普照
            [new THREE.Color(0x4F46E5), new THREE.Color(0x7C3AED), new THREE.Color(0xC026D3), new THREE.Color(0xDB2777), new THREE.Color(0x8B5CF6)],
            // 妖魔鬼怪
            [new THREE.Color(0x10B981), new THREE.Color(0xA3E635), new THREE.Color(0xFACC15), new THREE.Color(0xFB923C), new THREE.Color(0x4ADE80)],
            // 取经路上
            [new THREE.Color(0xEC4899), new THREE.Color(0x8B5CF6), new THREE.Color(0x6366F1), new THREE.Color(0x3B82F6), new THREE.Color(0xA855F7)]
        ];

        // 西游记核心角色数据
        const xiyoujiCharacters = [
            // 太阳中心 - 至高神
            { id: 'c0008', name: '玉皇大帝', celestial: 'sun', importance: 1.0, type: 'deity', aliases: ['昊天上帝', '天帝'], color: '#FFD700' },
            
            // 水星 - 佛教圣地
            { id: 'c0006', name: '如来佛祖', celestial: 'mercury', importance: 1.0, type: 'buddha', aliases: ['释迦牟尼', '佛祖'], color: '#87CEEB' },
            { id: 'c0015', name: '文殊菩萨', celestial: 'mercury', importance: 0.8, type: 'buddha', aliases: ['文殊师利'], color: '#87CEEB' },
            
            // 金星 - 观音净土
            { id: 'c0007', name: '观音菩萨', celestial: 'venus', importance: 0.95, type: 'buddha', aliases: ['观世音', '南海观音'], color: '#FFC649' },
            
            // 地球 - 取经团队
            { id: 'c0001', name: '孙悟空', celestial: 'earth', importance: 1.0, type: 'protagonist', aliases: ['美猴王', '齐天大圣', '孙行者', '斗战胜佛'], color: '#FF6B6B' },
            { id: 'c0002', name: '唐僧', celestial: 'earth', importance: 0.9, type: 'protagonist', aliases: ['玄奘', '三藏法师', '金蝉子'], color: '#FF6B6B' },
            { id: 'c0003', name: '猪八戒', celestial: 'earth', importance: 0.8, type: 'protagonist', aliases: ['猪悟能', '天蓬元帅'], color: '#FF6B6B' },
            { id: 'c0004', name: '沙僧', celestial: 'earth', importance: 0.7, type: 'protagonist', aliases: ['沙悟净', '卷帘大将'], color: '#FF6B6B' },
            { id: 'c0005', name: '白龙马', celestial: 'earth', importance: 0.6, type: 'protagonist', aliases: ['敖烈', '三太子'], color: '#FF6B6B' },
            
            // 火星 - 妖魔世界
            { id: 'c0010', name: '牛魔王', celestial: 'mars', importance: 0.85, type: 'demon', aliases: ['大力王'], color: '#DC143C' },
            { id: 'c0021', name: '铁扇公主', celestial: 'mars', importance: 0.75, type: 'demon', aliases: ['罗刹女'], color: '#DC143C' },
            { id: 'c0022', name: '红孩儿', celestial: 'mars', importance: 0.7, type: 'demon', aliases: ['圣婴大王'], color: '#DC143C' },
            { id: 'c0023', name: '白骨精', celestial: 'mars', importance: 0.65, type: 'demon', aliases: ['白骨夫人'], color: '#DC143C' },
            
            // 木星 - 妖王联盟
            { id: 'c0024', name: '金角大王', celestial: 'jupiter', importance: 0.6, type: 'demon', aliases: [], color: '#8B4513' },
            { id: 'c0025', name: '银角大王', celestial: 'jupiter', importance: 0.6, type: 'demon', aliases: [], color: '#8B4513' },
            
            // 土星 - 天庭众神
            { id: 'c0011', name: '二郎神', celestial: 'saturn', importance: 0.8, type: 'deity', aliases: ['杨戬', '显圣真君'], color: '#4169E1' },
            { id: 'c0012', name: '哪吒', celestial: 'saturn', importance: 0.75, type: 'deity', aliases: ['三太子'], color: '#4169E1' },
            { id: 'c0013', name: '李天王', celestial: 'saturn', importance: 0.7, type: 'deity', aliases: ['托塔天王', '李靖'], color: '#4169E1' },
            { id: 'c0014', name: '太白金星', celestial: 'saturn', importance: 0.65, type: 'deity', aliases: [], color: '#4169E1' },
            
            // 天王星 - 道教仙人
            { id: 'c0009', name: '太上老君', celestial: 'uranus', importance: 0.9, type: 'immortal', aliases: ['老子', '道德天尊'], color: '#4FD0E7' },
            
            // 海王星 - 其他角色
            { id: 'c0026', name: '镇元大仙', celestial: 'neptune', importance: 0.6, type: 'immortal', aliases: ['地仙之祖'], color: '#000080' }
        ];

        // 关系数据
        const relationships = [
            // 师徒关系
            { from: 'c0002', to: 'c0001', type: 'master_disciple', strength: 0.9, color: '#4CAF50' },
            { from: 'c0002', to: 'c0003', type: 'master_disciple', strength: 0.8, color: '#4CAF50' },
            { from: 'c0002', to: 'c0004', type: 'master_disciple', strength: 0.85, color: '#4CAF50' },
            { from: 'c0002', to: 'c0005', type: 'master_disciple', strength: 0.7, color: '#4CAF50' },
            
            // 同门关系
            { from: 'c0001', to: 'c0003', type: 'fellow_disciple', strength: 0.7, color: '#FF9800' },
            { from: 'c0001', to: 'c0004', type: 'fellow_disciple', strength: 0.8, color: '#FF9800' },
            { from: 'c0003', to: 'c0004', type: 'fellow_disciple', strength: 0.75, color: '#FF9800' },
            
            // 家族关系
            { from: 'c0010', to: 'c0021', type: 'family', strength: 0.8, color: '#E91E63' },
            { from: 'c0010', to: 'c0022', type: 'family', strength: 0.9, color: '#E91E63' },
            { from: 'c0021', to: 'c0022', type: 'family', strength: 0.9, color: '#E91E63' },
            
            // 敌对关系
            { from: 'c0001', to: 'c0023', type: 'enemy', strength: 0.9, color: '#F44336' },
            { from: 'c0001', to: 'c0010', type: 'enemy', strength: 0.8, color: '#F44336' },
            { from: 'c0001', to: 'c0024', type: 'enemy', strength: 0.7, color: '#F44336' },
            { from: 'c0001', to: 'c0025', type: 'enemy', strength: 0.7, color: '#F44336' },
            
            // 上下级关系
            { from: 'c0008', to: 'c0011', type: 'superior', strength: 0.8, color: '#9C27B0' },
            { from: 'c0008', to: 'c0012', type: 'superior', strength: 0.75, color: '#9C27B0' },
            { from: 'c0008', to: 'c0013', type: 'superior', strength: 0.7, color: '#9C27B0' },
            
            // 佛教关系
            { from: 'c0006', to: 'c0007', type: 'buddhist', strength: 0.9, color: '#00BCD4' },
            { from: 'c0006', to: 'c0015', type: 'buddhist', strength: 0.8, color: '#00BCD4' }
        ];

        // 天体配置
        const celestialBodies = {
            sun: { position: [0, 0, 0], radius: 0, color: '#FFD700', name: '太阳中心' },
            mercury: { position: [0, 0, 0], radius: 8, color: '#87CEEB', name: '水星-佛界' },
            venus: { position: [0, 0, 0], radius: 12, color: '#FFC649', name: '金星-观音净土' },
            earth: { position: [0, 0, 0], radius: 16, color: '#6B93D6', name: '地球-取经团队' },
            mars: { position: [0, 0, 0], radius: 20, color: '#CD5C5C', name: '火星-妖魔世界' },
            jupiter: { position: [0, 0, 0], radius: 24, color: '#D2691E', name: '木星-妖王联盟' },
            saturn: { position: [0, 0, 0], radius: 28, color: '#FAD5A5', name: '土星-天庭众神' },
            uranus: { position: [0, 0, 0], radius: 32, color: '#4FD0E7', name: '天王星-道教仙人' },
            neptune: { position: [0, 0, 0], radius: 36, color: '#4169E1', name: '海王星-其他角色' }
        };

        // Three.js 场景设置
        let scene, camera, renderer, controls, composer;
        let nodes = [];
        let connections = [];
        let nodeGeometry, nodeMaterial;
        let connectionGeometry, connectionMaterial;
        let selectedNode = null;
        let pulseUniforms;

        function init() {
            // 创建场景
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0015);

            // 创建相机
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1200);
            camera.position.set(0, 5, 22);

            // 创建渲染器
            const canvasElement = document.getElementById('xiyouji-canvas');
            renderer = new THREE.WebGLRenderer({
                canvas: canvasElement,
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000);
            renderer.outputColorSpace = THREE.SRGBColorSpace;

            // 创建星空背景
            createStarField();

            // 创建控制器
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.5;
            controls.minDistance = 5;
            controls.maxDistance = 100;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.15;
            controls.enablePan = false;

            // 创建后处理管线
            setupPostProcessing();

            // 创建脉冲系统
            setupPulseSystem();

            // 创建角色节点
            createCharacterNodes();

            // 创建关系连线
            createRelationshipLines();

            // 设置初始布局
            switchLayout('galaxy');

            // 添加交互事件
            setupInteractions();

            // 设置主题切换
            setupThemeSelector();

            // 开始渲染循环
            animate();
        }

        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.68
            );
            composer.addPass(bloomPass);

            const filmPass = new FilmPass(0.35, 0.55, 2048, false);
            composer.addPass(filmPass);

            composer.addPass(new OutputPass());
        }

        function setupPulseSystem() {
            pulseUniforms = {
                uTime: { value: 0.0 },
                uPulsePositions: { value: [
                    new THREE.Vector3(1e3, 1e3, 1e3),
                    new THREE.Vector3(1e3, 1e3, 1e3),
                    new THREE.Vector3(1e3, 1e3, 1e3)
                ] },
                uPulseTimes: { value: [-1e3, -1e3, -1e3] },
                uPulseColors: { value: [
                    new THREE.Color(1, 1, 1),
                    new THREE.Color(1, 1, 1),
                    new THREE.Color(1, 1, 1)
                ] },
                uPulseSpeed: { value: 15.0 },
                uBaseNodeSize: { value: 0.5 },
                uActivePalette: { value: 0 }
            };
        }

        function createStarField() {
            const count = 8000;
            const positions = [];

            for (let i = 0; i < count; i++) {
                const r = THREE.MathUtils.randFloat(40, 120);
                const phi = Math.acos(THREE.MathUtils.randFloatSpread(2));
                const theta = THREE.MathUtils.randFloat(0, Math.PI * 2);
                positions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.15,
                sizeAttenuation: true,
                depthWrite: false,
                opacity: 0.8,
                transparent: true
            });

            const starField = new THREE.Points(geometry, material);
            scene.add(starField);
        }

        // 高级节点着色器
        const nodeShader = {
            vertexShader: `
                attribute float nodeSize;
                attribute float nodeType;
                attribute vec3 nodeColor;
                attribute float distanceFromRoot;

                uniform float uTime;
                uniform vec3 uPulsePositions[3];
                uniform float uPulseTimes[3];
                uniform float uPulseSpeed;
                uniform float uBaseNodeSize;

                varying vec3 vColor;
                varying float vNodeType;
                varying vec3 vPosition;
                varying float vPulseIntensity;
                varying float vDistanceFromRoot;

                float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) {
                    if (pulseTime < 0.0) return 0.0;
                    float timeSinceClick = uTime - pulseTime;
                    if (timeSinceClick < 0.0 || timeSinceClick > 3.0) return 0.0;

                    float pulseRadius = timeSinceClick * uPulseSpeed;
                    float distToClick = distance(worldPos, pulsePos);
                    float pulseThickness = 2.0;
                    float waveProximity = abs(distToClick - pulseRadius);

                    return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(3.0, 0.0, timeSinceClick);
                }

                void main() {
                    vNodeType = nodeType;
                    vColor = nodeColor;
                    vDistanceFromRoot = distanceFromRoot;

                    vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz;
                    vPosition = worldPos;

                    float totalPulseIntensity = 0.0;
                    for (int i = 0; i < 3; i++) {
                        totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);
                    }
                    vPulseIntensity = min(totalPulseIntensity, 1.0);

                    float timeScale = 0.5 + 0.5 * sin(uTime * 0.8 + distanceFromRoot * 0.2);
                    float baseSize = nodeSize * (0.8 + 0.2 * timeScale);
                    float pulseSize = baseSize * (1.0 + vPulseIntensity * 2.0);

                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = pulseSize * uBaseNodeSize * (800.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,

            fragmentShader: `
                uniform float uTime;
                uniform vec3 uPulseColors[3];
                uniform int uActivePalette;

                varying vec3 vColor;
                varying float vNodeType;
                varying vec3 vPosition;
                varying float vPulseIntensity;
                varying float vDistanceFromRoot;

                void main() {
                    vec2 center = 2.0 * gl_PointCoord - 1.0;
                    float dist = length(center);
                    if (dist > 1.0) discard;

                    float glowStrength = 1.0 - smoothstep(0.0, 1.0, dist);
                    glowStrength = pow(glowStrength, 1.4);

                    vec3 baseColor = vColor * (0.8 + 0.2 * sin(uTime * 0.5 + vDistanceFromRoot * 0.3));
                    vec3 finalColor = baseColor;

                    if (vPulseIntensity > 0.0) {
                        vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.3);
                        finalColor = mix(baseColor, pulseColor, vPulseIntensity);
                        finalColor *= (1.0 + vPulseIntensity * 0.7);
                    }

                    float alpha = glowStrength * (0.9 - 0.5 * dist);

                    float camDistance = length(vPosition - cameraPosition);
                    float distanceFade = smoothstep(80.0, 10.0, camDistance);

                    if (vNodeType > 0.5) {
                        alpha *= 0.85;
                    } else {
                        finalColor *= 1.2;
                    }

                    gl_FragColor = vec4(finalColor, alpha * distanceFade);
                }
            `
        };

        function createCharacterNodes() {
            const nodeCount = xiyoujiCharacters.length;
            const positions = new Float32Array(nodeCount * 3);
            const colors = new Float32Array(nodeCount * 3);
            const sizes = new Float32Array(nodeCount);
            const nodeTypes = new Float32Array(nodeCount);
            const distancesFromRoot = new Float32Array(nodeCount);

            xiyoujiCharacters.forEach((character, index) => {
                // 初始位置（稍后会被布局算法更新）
                positions[index * 3] = (Math.random() - 0.5) * 20;
                positions[index * 3 + 1] = (Math.random() - 0.5) * 20;
                positions[index * 3 + 2] = (Math.random() - 0.5) * 20;

                // 颜色
                const color = new THREE.Color(character.color);
                colors[index * 3] = color.r;
                colors[index * 3 + 1] = color.g;
                colors[index * 3 + 2] = color.b;

                // 大小基于重要性
                sizes[index] = 0.8 + character.importance * 1.2;

                // 节点类型
                nodeTypes[index] = character.type === 'protagonist' ? 1.0 : 0.0;

                // 距离根节点的距离（用于动画）
                distancesFromRoot[index] = index * 0.1;

                // 存储角色数据
                character.index = index;
                nodes.push(character);
            });

            // 创建几何体
            nodeGeometry = new THREE.BufferGeometry();
            nodeGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            nodeGeometry.setAttribute('nodeColor', new THREE.BufferAttribute(colors, 3));
            nodeGeometry.setAttribute('nodeSize', new THREE.BufferAttribute(sizes, 1));
            nodeGeometry.setAttribute('nodeType', new THREE.BufferAttribute(nodeTypes, 1));
            nodeGeometry.setAttribute('distanceFromRoot', new THREE.BufferAttribute(distancesFromRoot, 1));

            // 创建材质
            nodeMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    ...pulseUniforms,
                    uActivePalette: { value: config.activeTheme }
                },
                vertexShader: nodeShader.vertexShader,
                fragmentShader: nodeShader.fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            // 创建点云
            const nodePoints = new THREE.Points(nodeGeometry, nodeMaterial);
            scene.add(nodePoints);

            // 创建文字标签
            createNodeLabels();
        }

        function createNodeLabels() {
            xiyoujiCharacters.forEach((character, index) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;

                // 设置字体和样式
                context.fillStyle = 'rgba(255, 255, 255, 0.9)';
                context.font = 'bold 24px Inter, sans-serif';
                context.textAlign = 'center';
                context.textBaseline = 'middle';

                // 添加背景
                context.fillStyle = 'rgba(0, 0, 0, 0.6)';
                context.fillRect(0, 0, 256, 64);

                // 绘制文字
                context.fillStyle = character.color;
                context.fillText(character.name, 128, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    depthTest: false
                });

                const label = new THREE.Sprite(labelMaterial);
                label.scale.set(6, 1.5, 1);
                label.userData = { characterIndex: index, isLabel: true };

                scene.add(label);
                character.label = label;
            });
        }

        function createRelationshipLines() {
            const connectionCount = relationships.length;
            const positions = new Float32Array(connectionCount * 6); // 每条线2个点，每个点3个坐标
            const colors = new Float32Array(connectionCount * 6); // 每条线2个点，每个点3个颜色值
            const strengths = new Float32Array(connectionCount * 2); // 每条线2个点的强度

            relationships.forEach((rel, index) => {
                const fromChar = xiyoujiCharacters.find(c => c.id === rel.from);
                const toChar = xiyoujiCharacters.find(c => c.id === rel.to);

                if (fromChar && toChar) {
                    const startIndex = index * 6;
                    const colorIndex = index * 6;
                    const strengthIndex = index * 2;

                    // 起点位置（稍后会被布局更新）
                    positions[startIndex] = 0;
                    positions[startIndex + 1] = 0;
                    positions[startIndex + 2] = 0;

                    // 终点位置
                    positions[startIndex + 3] = 0;
                    positions[startIndex + 4] = 0;
                    positions[startIndex + 5] = 0;

                    // 连线颜色
                    const color = new THREE.Color(rel.color);
                    colors[colorIndex] = color.r;
                    colors[colorIndex + 1] = color.g;
                    colors[colorIndex + 2] = color.b;
                    colors[colorIndex + 3] = color.r;
                    colors[colorIndex + 4] = color.g;
                    colors[colorIndex + 5] = color.b;

                    // 连线强度
                    strengths[strengthIndex] = rel.strength;
                    strengths[strengthIndex + 1] = rel.strength;

                    rel.fromIndex = fromChar.index;
                    rel.toIndex = toChar.index;
                }
            });

            // 创建连线几何体
            connectionGeometry = new THREE.BufferGeometry();
            connectionGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            connectionGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            connectionGeometry.setAttribute('strength', new THREE.BufferAttribute(strengths, 1));

            // 创建连线材质
            connectionMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            // 创建连线对象
            const connectionLines = new THREE.LineSegments(connectionGeometry, connectionMaterial);
            scene.add(connectionLines);
            connections.push(connectionLines);
        }

        function updateConnectionPositions() {
            if (!connectionGeometry) return;

            const positions = connectionGeometry.attributes.position.array;
            const nodePositions = nodeGeometry.attributes.position.array;

            relationships.forEach((rel, index) => {
                if (rel.fromIndex !== undefined && rel.toIndex !== undefined) {
                    const startIndex = index * 6;
                    const fromIndex = rel.fromIndex * 3;
                    const toIndex = rel.toIndex * 3;

                    // 更新起点
                    positions[startIndex] = nodePositions[fromIndex];
                    positions[startIndex + 1] = nodePositions[fromIndex + 1];
                    positions[startIndex + 2] = nodePositions[fromIndex + 2];

                    // 更新终点
                    positions[startIndex + 3] = nodePositions[toIndex];
                    positions[startIndex + 4] = nodePositions[toIndex + 1];
                    positions[startIndex + 5] = nodePositions[toIndex + 2];
                }
            });

            connectionGeometry.attributes.position.needsUpdate = true;
        }

        function switchLayout(layoutType) {
            currentLayout = layoutType;
            document.getElementById('current-mode').textContent = getLayoutName(layoutType);

            switch(layoutType) {
                case 'galaxy':
                    applyGalaxyLayout();
                    break;
                case 'nine_heavens':
                    applyNineHeavensLayout();
                    break;
                case 'journey':
                    applyJourneyLayout();
                    break;
                case 'factions':
                    applyFactionsLayout();
                    break;
            }

            updateConnections();
        }

        function applyGalaxyLayout() {
            // 银河系螺旋布局
            const arms = 4;

            nodes.forEach((node, index) => {
                const character = node.userData;
                const celestialBody = celestialBodies[character.celestial];
                const baseRadius = celestialBody.radius;

                // 螺旋分布算法
                const armIndex = index % arms;
                const spiralAngle = (armIndex * Math.PI * 0.5) + (index / nodes.length) * Math.PI * 6;
                const radiusOffset = (1 - character.importance) * 3;
                const finalRadius = baseRadius + radiusOffset;

                const targetPosition = new THREE.Vector3(
                    Math.cos(spiralAngle) * finalRadius,
                    Math.sin(index * 0.1) * 2,
                    Math.sin(spiralAngle) * finalRadius
                );

                animateNodeToPosition(node, targetPosition);
            });
        }

        function applyNineHeavensLayout() {
            // 九重天分层布局
            const layers = 9;
            const layerHeight = 8;

            // 按重要性分层
            const sortedNodes = [...nodes].sort((a, b) => b.userData.importance - a.userData.importance);

            sortedNodes.forEach((node, index) => {
                const layer = Math.floor(index / (sortedNodes.length / layers));
                const positionInLayer = index % Math.ceil(sortedNodes.length / layers);
                const nodesInLayer = Math.ceil(sortedNodes.length / layers);

                const angle = (positionInLayer / nodesInLayer) * Math.PI * 2;
                const radius = 5 + layer * 3;
                const height = (layers - layer - 1) * layerHeight - (layers * layerHeight / 2);

                const targetPosition = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );

                animateNodeToPosition(node, targetPosition);
            });
        }

        function applyJourneyLayout() {
            // 取经路线布局
            const pathLength = 60;
            const spiralRadius = 15;

            // 按故事时间线排序（简化版）
            const journeyOrder = ['c0002', 'c0001', 'c0003', 'c0004', 'c0005']; // 取经团队优先
            const orderedNodes = [];

            // 先添加取经团队
            journeyOrder.forEach(id => {
                const node = nodes.find(n => n.userData.id === id);
                if (node) orderedNodes.push(node);
            });

            // 再添加其他角色
            nodes.forEach(node => {
                if (!orderedNodes.includes(node)) {
                    orderedNodes.push(node);
                }
            });

            orderedNodes.forEach((node, index) => {
                const t = index / (orderedNodes.length - 1);
                const angle = t * Math.PI * 4; // 2圈螺旋
                const z = (t - 0.5) * pathLength;

                const targetPosition = new THREE.Vector3(
                    Math.cos(angle) * spiralRadius * (1 - t * 0.3),
                    Math.sin(angle) * spiralRadius * (1 - t * 0.3),
                    z
                );

                animateNodeToPosition(node, targetPosition);
            });
        }

        function applyFactionsLayout() {
            // 势力阵营布局
            const factions = {
                protagonist: { center: new THREE.Vector3(0, 0, 0), nodes: [] },
                deity: { center: new THREE.Vector3(20, 10, 0), nodes: [] },
                buddha: { center: new THREE.Vector3(-20, 10, 0), nodes: [] },
                demon: { center: new THREE.Vector3(0, -10, 0), nodes: [] },
                immortal: { center: new THREE.Vector3(0, 10, 20), nodes: [] }
            };

            // 按类型分组
            nodes.forEach(node => {
                const type = node.userData.type;
                if (factions[type]) {
                    factions[type].nodes.push(node);
                } else {
                    factions.immortal.nodes.push(node); // 默认归类
                }
            });

            // 每个阵营内部布局
            Object.values(factions).forEach(faction => {
                faction.nodes.forEach((node, index) => {
                    const angle = (index / faction.nodes.length) * Math.PI * 2;
                    const radius = 3 + Math.random() * 5;

                    const offset = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        (Math.random() - 0.5) * 4,
                        Math.sin(angle) * radius
                    );

                    const targetPosition = faction.center.clone().add(offset);
                    animateNodeToPosition(node, targetPosition);
                });
            });
        }

        function animateNodeToPosition(node, targetPosition) {
            // 简单的位置动画
            const startPosition = node.position.clone();
            const duration = 2000; // 2秒
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // 使用缓动函数
                const easeProgress = 1 - Math.pow(1 - progress, 3);

                node.position.lerpVectors(startPosition, targetPosition, easeProgress);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            animate();
        }

        function updateConnections() {
            connections.forEach(connection => {
                const rel = connection.userData;
                const fromNode = nodes.find(n => n.userData.id === rel.from);
                const toNode = nodes.find(n => n.userData.id === rel.to);

                if (fromNode && toNode) {
                    const points = [fromNode.position, toNode.position];
                    connection.geometry.setFromPoints(points);
                }
            });
        }

        function setupInteractions() {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            renderer.domElement.addEventListener('click', (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                // 检测点击的节点
                const nodePoints = scene.children.find(child => child.type === 'Points');
                if (nodePoints) {
                    raycaster.params.Points.threshold = 2;
                    const intersects = raycaster.intersectObject(nodePoints);

                    if (intersects.length > 0) {
                        const index = intersects[0].index;
                        const character = xiyoujiCharacters[index];

                        // 创建脉冲效果
                        createPulseEffect(intersects[0].point);

                        // 显示角色信息
                        showCharacterInfo(character);

                        // 高亮相关节点
                        highlightRelatedNodes(character);
                    }
                }
            });
        }

        function createPulseEffect(position) {
            // 找到空闲的脉冲槽
            for (let i = 0; i < 3; i++) {
                if (pulseUniforms.uPulseTimes.value[i] < pulseUniforms.uTime.value - 3) {
                    pulseUniforms.uPulsePositions.value[i].copy(position);
                    pulseUniforms.uPulseTimes.value[i] = pulseUniforms.uTime.value;
                    pulseUniforms.uPulseColors.value[i] = xiyoujiThemes[config.activeTheme][0];
                    break;
                }
            }
        }

        function setupThemeSelector() {
            const themeButtons = document.querySelectorAll('.theme-button');

            themeButtons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    // 更新活动主题
                    config.activeTheme = index;

                    // 更新按钮状态
                    themeButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');

                    // 更新着色器
                    if (nodeMaterial) {
                        nodeMaterial.uniforms.uActivePalette.value = index;
                    }

                    // 更新节点颜色
                    updateNodeColors();
                });
            });
        }

        function updateNodeColors() {
            if (!nodeGeometry) return;

            const colors = nodeGeometry.attributes.nodeColor.array;
            const theme = xiyoujiThemes[config.activeTheme];

            xiyoujiCharacters.forEach((character, index) => {
                let themeColor;
                switch(character.type) {
                    case 'protagonist': themeColor = theme[0]; break;
                    case 'deity': themeColor = theme[1]; break;
                    case 'buddha': themeColor = theme[2]; break;
                    case 'demon': themeColor = theme[3]; break;
                    default: themeColor = theme[4]; break;
                }

                colors[index * 3] = themeColor.r;
                colors[index * 3 + 1] = themeColor.g;
                colors[index * 3 + 2] = themeColor.b;
            });

            nodeGeometry.attributes.nodeColor.needsUpdate = true;
        }

        function showCharacterInfo(character) {
            document.getElementById('char-name').textContent = character.name;
            document.getElementById('char-type').textContent = getTypeDisplayName(character.type);
            document.getElementById('char-celestial').textContent = celestialBodies[character.celestial].name;
            document.getElementById('char-importance').textContent = (character.importance * 100).toFixed(0) + '%';
            document.getElementById('char-aliases').textContent = character.aliases.join(', ') || '无';

            // 显示关系
            const relatedRels = relationships.filter(rel =>
                rel.from === character.id || rel.to === character.id
            );

            const relationshipsHtml = relatedRels.map(rel => {
                const isFrom = rel.from === character.id;
                const otherId = isFrom ? rel.to : rel.from;
                const otherChar = xiyoujiCharacters.find(c => c.id === otherId);
                const direction = isFrom ? '→' : '←';

                return `<div class="relationship-item">
                    <span class="relation-type">${getRelationDisplayName(rel.type)}</span>
                    ${direction} ${otherChar ? otherChar.name : '未知'}
                </div>`;
            }).join('');

            document.getElementById('relationships').innerHTML = relationshipsHtml;
            document.getElementById('info-panel').style.display = 'block';

            selectedNode = character;
        }

        function highlightRelatedNodes(selectedCharacter) {
            // 重置所有节点大小
            const sizes = nodeGeometry.attributes.nodeSize.array;
            xiyoujiCharacters.forEach((char, index) => {
                sizes[index] = 0.8 + char.importance * 1.2;
            });

            // 高亮选中节点
            const selectedIndex = selectedCharacter.index;
            sizes[selectedIndex] = 2.5;

            // 高亮相关节点
            const relatedIds = relationships
                .filter(rel => rel.from === selectedCharacter.id || rel.to === selectedCharacter.id)
                .map(rel => rel.from === selectedCharacter.id ? rel.to : rel.from);

            relatedIds.forEach(id => {
                const relatedChar = xiyoujiCharacters.find(c => c.id === id);
                if (relatedChar) {
                    sizes[relatedChar.index] = 1.8;
                }
            });

            nodeGeometry.attributes.nodeSize.needsUpdate = true;
        }

        function switchLayout(layoutType) {
            config.currentLayout = layoutType;
            document.getElementById('current-mode').textContent = getLayoutName(layoutType);

            // 更新按钮状态
            document.querySelectorAll('.control-button').forEach(btn => {
                btn.classList.remove('active');
            });
            const targetButton = Array.from(document.querySelectorAll('.control-button'))
                .find(btn => btn.textContent.includes(getLayoutName(layoutType).split('')[0]));
            if (targetButton) targetButton.classList.add('active');

            switch(layoutType) {
                case 'galaxy':
                    applyGalaxyLayout();
                    break;
                case 'nine_heavens':
                    applyNineHeavensLayout();
                    break;
                case 'journey':
                    applyJourneyLayout();
                    break;
                case 'factions':
                    applyFactionsLayout();
                    break;
            }
        }

        function applyGalaxyLayout() {
            if (!nodeGeometry) return;

            const positions = nodeGeometry.attributes.position.array;
            const arms = 4;

            xiyoujiCharacters.forEach((character, index) => {
                const celestialBody = celestialBodies[character.celestial];
                const baseRadius = celestialBody.radius;

                // 螺旋分布算法
                const armIndex = index % arms;
                const spiralAngle = (armIndex * Math.PI * 0.5) + (index / xiyoujiCharacters.length) * Math.PI * 6;
                const radiusOffset = (1 - character.importance) * 3;
                const finalRadius = baseRadius + radiusOffset;

                positions[index * 3] = Math.cos(spiralAngle) * finalRadius;
                positions[index * 3 + 1] = Math.sin(index * 0.1) * 2;
                positions[index * 3 + 2] = Math.sin(spiralAngle) * finalRadius;
            });

            nodeGeometry.attributes.position.needsUpdate = true;
        }

        function applyNineHeavensLayout() {
            if (!nodeGeometry) return;

            const positions = nodeGeometry.attributes.position.array;
            const layers = 9;
            const layerHeight = 8;

            // 按重要性分层
            const sortedChars = [...xiyoujiCharacters].sort((a, b) => b.importance - a.importance);

            sortedChars.forEach((character, sortedIndex) => {
                const index = character.index;
                const layer = Math.floor(sortedIndex / (sortedChars.length / layers));
                const positionInLayer = sortedIndex % Math.ceil(sortedChars.length / layers);
                const nodesInLayer = Math.ceil(sortedChars.length / layers);

                const angle = (positionInLayer / nodesInLayer) * Math.PI * 2;
                const radius = 5 + layer * 3;
                const height = (layers - layer - 1) * layerHeight - (layers * layerHeight / 2);

                positions[index * 3] = Math.cos(angle) * radius;
                positions[index * 3 + 1] = height;
                positions[index * 3 + 2] = Math.sin(angle) * radius;
            });

            nodeGeometry.attributes.position.needsUpdate = true;
        }

        function applyJourneyLayout() {
            if (!nodeGeometry) return;

            const positions = nodeGeometry.attributes.position.array;
            const pathLength = 60;
            const spiralRadius = 15;

            // 按故事时间线排序（简化版）
            const journeyOrder = ['c0002', 'c0001', 'c0003', 'c0004', 'c0005'];
            const orderedChars = [];

            // 先添加取经团队
            journeyOrder.forEach(id => {
                const char = xiyoujiCharacters.find(c => c.id === id);
                if (char) orderedChars.push(char);
            });

            // 再添加其他角色
            xiyoujiCharacters.forEach(char => {
                if (!orderedChars.includes(char)) {
                    orderedChars.push(char);
                }
            });

            orderedChars.forEach((character, orderedIndex) => {
                const index = character.index;
                const t = orderedIndex / (orderedChars.length - 1);
                const angle = t * Math.PI * 4; // 2圈螺旋
                const z = (t - 0.5) * pathLength;

                positions[index * 3] = Math.cos(angle) * spiralRadius * (1 - t * 0.3);
                positions[index * 3 + 1] = Math.sin(angle) * spiralRadius * (1 - t * 0.3);
                positions[index * 3 + 2] = z;
            });

            nodeGeometry.attributes.position.needsUpdate = true;
        }

        function applyFactionsLayout() {
            if (!nodeGeometry) return;

            const positions = nodeGeometry.attributes.position.array;
            const factions = {
                protagonist: { center: [0, 0, 0], chars: [] },
                deity: { center: [20, 10, 0], chars: [] },
                buddha: { center: [-20, 10, 0], chars: [] },
                demon: { center: [0, -10, 0], chars: [] },
                immortal: { center: [0, 10, 20], chars: [] }
            };

            // 按类型分组
            xiyoujiCharacters.forEach(char => {
                const type = char.type;
                if (factions[type]) {
                    factions[type].chars.push(char);
                } else {
                    factions.immortal.chars.push(char);
                }
            });

            // 每个阵营内部布局
            Object.values(factions).forEach(faction => {
                faction.chars.forEach((character, charIndex) => {
                    const index = character.index;
                    const angle = (charIndex / faction.chars.length) * Math.PI * 2;
                    const radius = 3 + Math.random() * 5;

                    positions[index * 3] = faction.center[0] + Math.cos(angle) * radius;
                    positions[index * 3 + 1] = faction.center[1] + (Math.random() - 0.5) * 4;
                    positions[index * 3 + 2] = faction.center[2] + Math.sin(angle) * radius;
                });
            });

            nodeGeometry.attributes.position.needsUpdate = true;
        }

        function showCharacterInfo(character) {
            document.getElementById('char-name').textContent = character.name;
            document.getElementById('char-type').textContent = getTypeDisplayName(character.type);
            document.getElementById('char-celestial').textContent = celestialBodies[character.celestial].name;
            document.getElementById('char-importance').textContent = (character.importance * 100).toFixed(0) + '%';
            document.getElementById('char-aliases').textContent = character.aliases.join(', ') || '无';

            // 显示关系
            const relatedRels = relationships.filter(rel =>
                rel.from === character.id || rel.to === character.id
            );

            const relationshipsHtml = relatedRels.map(rel => {
                const isFrom = rel.from === character.id;
                const otherId = isFrom ? rel.to : rel.from;
                const otherChar = xiyoujiCharacters.find(c => c.id === otherId);
                const direction = isFrom ? '→' : '←';

                return `<div class="relationship-item">
                    <span class="relation-type">${getRelationDisplayName(rel.type)}</span>
                    ${direction} ${otherChar ? otherChar.name : '未知'}
                </div>`;
            }).join('');

            document.getElementById('relationships').innerHTML = relationshipsHtml;
            document.getElementById('info-panel').style.display = 'block';
        }

        function highlightRelatedNodes(selectedNode) {
            // 重置所有节点
            nodes.forEach(node => {
                node.material.emissiveIntensity = 0.2;
                node.scale.set(1, 1, 1);
            });

            // 高亮选中节点
            selectedNode.material.emissiveIntensity = 0.8;
            selectedNode.scale.set(1.5, 1.5, 1.5);

            // 高亮相关节点
            const relatedIds = relationships
                .filter(rel => rel.from === selectedNode.userData.id || rel.to === selectedNode.userData.id)
                .map(rel => rel.from === selectedNode.userData.id ? rel.to : rel.from);

            relatedIds.forEach(id => {
                const relatedNode = nodes.find(n => n.userData.id === id);
                if (relatedNode) {
                    relatedNode.material.emissiveIntensity = 0.5;
                    relatedNode.scale.set(1.2, 1.2, 1.2);
                }
            });
        }

        function toggleConnections() {
            showConnections = !showConnections;
            connections.forEach(connection => {
                connection.visible = showConnections;
            });
        }

        function resetView() {
            camera.position.set(0, 20, 50);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        function closeInfoPanel() {
            document.getElementById('info-panel').style.display = 'none';

            // 重置所有节点高亮
            nodes.forEach(node => {
                node.material.emissiveIntensity = 0.2;
                node.scale.set(1, 1, 1);
            });
        }

        function getLayoutName(layoutType) {
            const names = {
                galaxy: '银河系全景',
                nine_heavens: '九重天分层',
                journey: '取经路线',
                factions: '势力阵营'
            };
            return names[layoutType] || '未知布局';
        }

        function getTypeDisplayName(type) {
            const names = {
                protagonist: '主角',
                deity: '天庭神仙',
                buddha: '佛教圣者',
                demon: '妖魔',
                immortal: '道教仙人'
            };
            return names[type] || type;
        }

        function getRelationDisplayName(relType) {
            const names = {
                master_disciple: '师徒',
                fellow_disciple: '同门',
                family: '家族',
                enemy: '敌对',
                superior: '上下级',
                buddhist: '佛教'
            };
            return names[relType] || relType;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!config.paused) {
                const time = performance.now() * 0.001;
                pulseUniforms.uTime.value = time;

                controls.update();

                // 更新标签位置
                updateLabelPositions();

                // 更新连线位置
                updateConnectionPositions();

                // 渲染
                composer.render();
            }
        }

        function updateLabelPositions() {
            if (!nodeGeometry) return;

            const positions = nodeGeometry.attributes.position.array;

            xiyoujiCharacters.forEach((character, index) => {
                if (character.label) {
                    const x = positions[index * 3];
                    const y = positions[index * 3 + 1];
                    const z = positions[index * 3 + 2];

                    character.label.position.set(x, y + 2, z);

                    // 根据距离调整标签大小
                    const distance = camera.position.distanceTo(character.label.position);
                    const scale = Math.max(0.5, Math.min(2, 20 / distance));
                    character.label.scale.set(6 * scale, 1.5 * scale, 1);
                }
            });
        }

        function toggleConnections() {
            config.showConnections = !config.showConnections;
            connections.forEach(connection => {
                connection.visible = config.showConnections;
            });

            // 更新按钮状态
            const button = document.querySelector('.control-button[onclick*="toggleConnections"]');
            if (button) {
                button.classList.toggle('active', config.showConnections);
            }
        }

        function resetView() {
            camera.position.set(0, 5, 22);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        function closeInfoPanel() {
            document.getElementById('info-panel').style.display = 'none';
            selectedNode = null;
        }

        function getLayoutName(layoutType) {
            const names = {
                galaxy: '银河系全景',
                nine_heavens: '九重天分层',
                journey: '取经路线',
                factions: '势力阵营'
            };
            return names[layoutType] || '未知布局';
        }

        function getTypeDisplayName(type) {
            const names = {
                protagonist: '主角',
                deity: '天庭神仙',
                buddha: '佛教圣者',
                demon: '妖魔',
                immortal: '道教仙人'
            };
            return names[type] || type;
        }

        function getRelationDisplayName(relType) {
            const names = {
                master_disciple: '师徒',
                fellow_disciple: '同门',
                family: '家族',
                enemy: '敌对',
                superior: '上下级',
                buddhist: '佛教'
            };
            return names[relType] || relType;
        }

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // 初始化
        init();

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 初始化
        init();
    </script>
</body>
</html>
