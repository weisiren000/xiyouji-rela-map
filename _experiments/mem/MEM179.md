# MEM179: React无限循环修复备忘录

## 快速诊断清单
- [ ] 检查控制台是否有"Maximum update depth exceeded"错误
- [ ] 确认错误是否来自useEffect中的状态更新
- [ ] 查看是否有zustand/redux等状态管理库的函数调用
- [ ] 检查useEffect的依赖数组是否包含状态更新函数

## 核心修复模板

### 问题代码模式
```tsx
// ❌ 可能导致无限循环
useEffect(() => {
  if (someCondition) {
    setSomeState(newValue)  // 每次都调用，即使值相同
  }
}, [stateValue]) // stateValue变化 → 调用setSomeState → stateValue变化 → 循环
```

### 修复代码模板
```tsx
// ✅ 使用ref避免无限循环
const previousValueRef = useRef<any>(null)

useEffect(() => {
  if (currentValue !== previousValueRef.current) {
    previousValueRef.current = currentValue
    if (someCondition) {
      setSomeState(newValue)  // 只在真正变化时调用
    }
  }
}, [currentValue])
```

## 常见陷阱

### 1. zustand函数在依赖数组中
```tsx
// ❌ 错误：zustand函数在依赖数组中
const { setState } = useStore()
useEffect(() => {
  setState(newValue)
}, [setState]) // setState是稳定的，不应在依赖数组中

// ✅ 正确：移除稳定函数
useEffect(() => {
  setState(newValue)
}, [newValue]) // 只依赖真正变化的值
```

### 2. 对象/数组的浅比较问题
```tsx
// ❌ 对象引用每次都不同
const obj = { value: someValue }
useEffect(() => {
  updateState(obj)
}, [obj]) // obj每次渲染都是新的引用

// ✅ 使用useMemo稳定引用
const obj = useMemo(() => ({ value: someValue }), [someValue])
useEffect(() => {
  updateState(obj)
}, [obj])
```

### 3. 回调函数的重新创建
```tsx
// ❌ 回调函数每次都重新创建
const handleUpdate = (value) => updateState(value)
useEffect(() => {
  bindEvents(handleUpdate)
}, [handleUpdate]) // handleUpdate每次都不同

// ✅ 使用useCallback稳定函数
const handleUpdate = useCallback((value) => updateState(value), [])
useEffect(() => {
  bindEvents(handleUpdate)
}, [handleUpdate])
```

## 调试技巧

### 1. 添加日志跟踪
```tsx
useEffect(() => {
  console.log('Effect triggered', { dependency1, dependency2 })
  // 状态更新逻辑
}, [dependency1, dependency2])
```

### 2. 使用React DevTools
- Profiler：查看组件重渲染次数
- Components：检查state和props的变化

### 3. 条件断点
```tsx
useEffect(() => {
  debugger // 在这里设置断点，检查调用栈
  setState(newValue)
}, [dependency])
```

## 预防清单
- [ ] useEffect中避免直接调用状态更新函数
- [ ] 使用useCallback/useMemo稳定引用
- [ ] 从依赖数组中移除稳定的函数引用
- [ ] 实现变化检测机制
- [ ] 定期检查组件重渲染性能

## 应急修复步骤
1. **立即停止循环**：注释掉problematic useEffect
2. **定位根因**：检查依赖数组和状态更新逻辑
3. **应用ref方案**：使用previousValueRef模板
4. **测试验证**：确认功能正常且无性能问题
5. **长期优化**：重构状态管理架构

## 相关文件
- `CharacterSpheresSimple.tsx`：主要修复文件
- `useCharacterInfoStore.ts`：相关状态管理
- `useGalaxyCharacterDrag.ts`：交互逻辑hook

## 性能监控指标
- 组件重渲染次数 < 预期值
- useEffect执行频率 < 阈值
- WebGL上下文稳定性 ✓
- 用户交互响应时间 < 100ms
