# EXP163: 基于视角的拖拽算法实现

## 时间
2025-06-28

## 问题背景
用户指出拖动应该是基于视角的平移，而不是基于世界坐标系的移动。原有的拖拽算法虽然考虑了相机方向，但移动方式不够直观，需要改进为完全基于用户视角的拖拽体验。

## 需求分析
### 用户期望的拖拽行为
- **视角一致性**: 鼠标向右移动，物体在屏幕上向右移动
- **深度保持**: 拖拽时物体保持与相机的相对距离
- **直觉操作**: 移动方向完全跟随用户的视角方向
- **精确控制**: 鼠标移动与物体移动的比例合理

### 技术挑战
- 将2D屏幕坐标转换为3D世界坐标
- 保持物体在相机视野中的相对位置
- 处理不同相机角度和距离的情况
- 确保拖拽的平滑性和精确性

## 解决方案

### 1. 射线投影拖拽算法（主要方法）
**核心思路**: 通过射线与平面的交点计算精确的拖拽位置

#### 算法步骤
```typescript
function calculateDragPositionByRayProjection(
  camera: any,
  canvas: HTMLCanvasElement,
  startMouse: Vector2,
  currentMouse: Vector2,
  startPosition: Vector3
): Vector3 {
  // 1. 创建垂直于相机视线的平面，通过起始位置
  const cameraDirection = new Vector3()
  camera.getWorldDirection(cameraDirection)
  const dragPlane = new Plane(cameraDirection, -cameraDirection.dot(startPosition))
  
  // 2. 计算起始和当前鼠标位置的射线
  const startRaycaster = new Raycaster()
  const currentRaycaster = new Raycaster()
  
  // 3. 计算射线与平面的交点
  const startIntersection = new Vector3()
  const currentIntersection = new Vector3()
  
  // 4. 计算移动向量并应用
  const movement = currentIntersection.sub(startIntersection)
  const newPosition = startPosition.clone().add(movement)
  
  return newPosition
}
```

#### 技术优势
- **精确性**: 基于数学上精确的射线-平面交点计算
- **视角一致**: 移动完全基于用户的视角方向
- **深度保持**: 物体始终保持在相同的视觉深度
- **角度无关**: 适用于任意相机角度和位置

### 2. 视角平移算法（备用方法）
**核心思路**: 基于相机视野和距离的简化平移计算

#### 算法步骤
```typescript
function calculateDragPositionByViewProjection(
  camera: any,
  canvas: HTMLCanvasElement,
  startMouse: Vector2,
  currentMouse: Vector2,
  startPosition: Vector3
): Vector3 {
  // 1. 计算NDC坐标移动
  const ndcDelta = new Vector2(
    (mouseDelta.x / canvas.clientWidth) * 2,
    -(mouseDelta.y / canvas.clientHeight) * 2
  )
  
  // 2. 获取相机的右向量和上向量
  const cameraRight = new Vector3().setFromMatrixColumn(cameraMatrix, 0)
  const cameraUp = new Vector3().setFromMatrixColumn(cameraMatrix, 1)
  
  // 3. 根据视野角度计算移动比例
  const fov = camera.fov * Math.PI / 180
  const viewHeight = 2 * Math.tan(fov / 2) * cameraDistance
  const viewWidth = viewHeight * camera.aspect
  
  // 4. 计算3D移动向量
  const rightMovement = cameraRight.clone().multiplyScalar(ndcDelta.x * viewWidth * 0.5)
  const upMovement = cameraUp.clone().multiplyScalar(ndcDelta.y * viewHeight * 0.5)
  
  return newPosition
}
```

#### 技术特点
- **简化计算**: 基于相机矩阵的直接计算
- **性能优化**: 计算量较小，适合实时操作
- **容错性**: 作为射线投影的备用方案
- **兼容性**: 适用于各种相机配置

### 3. 双重保障机制
**实现策略**: 主要方法 + 备用方法 + 错误处理

```typescript
try {
  // 方法1: 基于射线投影的精确拖拽
  newPosition = calculateDragPositionByRayProjection(
    camera, canvas, startMouse, currentMouse, startPosition
  )
} catch (error) {
  console.warn('射线投影拖拽失败，使用备用方法:', error)
  // 方法2: 备用的视角平移方法
  newPosition = calculateDragPositionByViewProjection(
    camera, canvas, startMouse, currentMouse, startPosition
  )
}
```

## 技术实现细节

### 坐标系转换
1. **屏幕坐标 → NDC坐标**: 将像素坐标转换为标准化设备坐标
2. **NDC坐标 → 射线**: 通过相机矩阵生成3D射线
3. **射线 → 世界坐标**: 计算射线与拖拽平面的交点

### 平面定义
- **法向量**: 相机的视线方向
- **通过点**: 拖拽起始位置
- **数学表达**: `plane.normal.dot(point) + plane.constant = 0`

### 移动计算
- **起始交点**: 拖拽开始时鼠标射线与平面的交点
- **当前交点**: 当前鼠标射线与平面的交点
- **移动向量**: 当前交点 - 起始交点
- **新位置**: 起始位置 + 移动向量

## 实施成果

### ✅ 完成的功能
1. **射线投影拖拽** - 基于数学精确计算的主要拖拽方法
2. **视角平移拖拽** - 简化计算的备用拖拽方法
3. **双重保障机制** - 主备方案确保拖拽功能的稳定性
4. **错误处理** - 完善的异常捕获和降级处理
5. **调试日志** - 详细的拖拽过程日志记录

### 文件变更统计
- 修改文件：2个
  - `src/hooks/useEventCharacterInteraction.ts` (核心算法)
  - `src/components/three/Scenes/EventDetailScene/EventDetailScene.tsx` (用户提示)
- 新增代码：约100行
- 新增函数：2个拖拽计算函数

### 算法性能
- **射线投影**: 高精度，适中计算量
- **视角平移**: 中等精度，低计算量
- **错误处理**: 零性能损失的降级机制

## 技术亮点

### 1. 数学精确性
- 基于射线-平面交点的精确几何计算
- 考虑相机的完整变换矩阵
- 处理任意相机角度和位置

### 2. 用户体验优化
- 拖拽方向完全符合用户直觉
- 移动距离与鼠标移动成正比
- 保持物体的视觉深度一致性

### 3. 鲁棒性设计
- 主备算法双重保障
- 完善的错误处理机制
- 详细的调试信息输出

### 4. 性能考虑
- 避免不必要的重复计算
- 使用Three.js内置的优化方法
- 合理的计算复杂度平衡

## 用户体验改进

### 拖拽行为对比
**改进前**:
- 移动方向可能与视角不一致
- 不同相机角度下行为不统一
- 移动距离难以预测

**改进后**:
- 移动方向完全跟随视角
- 任意相机角度下行为一致
- 移动距离直观可控

### 操作直觉性
- **向右拖拽**: 物体在屏幕上向右移动
- **向上拖拽**: 物体在屏幕上向上移动
- **对角拖拽**: 物体沿对角线移动
- **距离感知**: 移动距离与鼠标移动成比例

## 测试验证

### 功能测试要点
1. **基本拖拽**: 各个方向的拖拽是否符合预期
2. **视角变化**: 不同相机角度下拖拽是否一致
3. **距离测试**: 不同相机距离下的拖拽精度
4. **边界情况**: 极端角度和距离的处理
5. **错误恢复**: 算法失败时的备用方案

### 预期效果
- 拖拽方向与鼠标移动方向完全一致
- 不同视角下的拖拽行为保持统一
- 移动距离与鼠标移动距离成正比
- 控制台显示详细的拖拽计算信息

## 数学原理

### 射线-平面交点公式
```
射线: P(t) = origin + t * direction
平面: normal · P + d = 0
交点: t = -(normal · origin + d) / (normal · direction)
```

### 视角投影公式
```
视野高度: viewHeight = 2 * tan(fov/2) * distance
视野宽度: viewWidth = viewHeight * aspect
移动比例: scale = viewSize * ndcDelta * 0.5
```

## 扩展性考虑
1. **约束拖拽**: 可添加拖拽路径约束
2. **吸附功能**: 可实现网格吸附或对象吸附
3. **多选拖拽**: 可扩展为同时拖拽多个对象
4. **动画插值**: 可添加拖拽过程的平滑动画

## 学习收获
1. **3D数学**: 射线、平面、坐标变换的实际应用
2. **用户体验**: 直觉操作与技术实现的平衡
3. **算法设计**: 主备方案的鲁棒性设计
4. **性能优化**: 实时计算的性能考虑

## 下一步优化
1. **移动端适配**: 触摸拖拽的特殊处理
2. **拖拽约束**: 添加边界和路径限制
3. **视觉反馈**: 拖拽过程的实时预览
4. **性能监控**: 拖拽操作的性能指标
